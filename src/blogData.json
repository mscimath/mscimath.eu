[  {
    "general" : [
        {
            "postTitle": "Bitcoin: A Peer-to-Peer Electronic Cash System",
            "postLines": [
                {"line": "Satoshi Nakamoto", "code": false},
                {"line": "satoshin@gmx.com", "code": false},
                {"line": "www.bitcoin.org", "code": false},
                {"line": "Abstract. A purely peer-to-peer version of electronic cash would allow online payments to be sent directly from one party to another without going through a financial institution. Digital signatures provide part of the solution, but the main benefits are lost if a trusted third party is still required to prevent double-spending. We propose a solution to the double-spending problem using a peer-to-peer network. The network timestamps transactions by hashing them into an ongoing chain of hash-based proof-of-work, forming a record that cannot be changed without redoing the proof-of-work. The longest chain not only serves as proof of the sequence of events witnessed, but proof that it came from the largest pool of CPU power. As long as a mojority of CPU power is controlled by nodes that are not cooperating to attack the network, they'll generate the longest chain and outpace attackers. The network itself requires minimal structure. Messages are broadcast on a best effort basis, and nodes can leave and rejoin the network at will, accepting the longest proof-of-work chain as proof of what happened while they were gone.", "code": false},
                {"line": "1. Introduction", "code": false},
                {"line": "Commerce on the Internet has come to rely almost exclusively on financial institutions serving as trusted third parties to process electronic payments. While the system works well enough for most transactions, it still suffers from the inherent weaknesses of the trust based model. Completely non-reversible transactions are not really possible, since financial institutions cannot avoid mediating disputes. The cost of mediation increases transaction costs, limiting the minimum practical transaction size and cutting off the possibility for small casual transactions, and there is a broader cost in the loss of ability to make non-reversible payments for non reversible services. With the possibility of reversal, the need for trust spreads. Merchants must be wary of their customers, hassling them for more information than they would otherwise need. A certain percentage of fraud is accepted as unavoidable. These costs and payment uncertainties can be avoided in person by using physical currency, but no mechanism exists to make payments over a communications channel without a trusted party.", "code": false},
                {"line": "What is needed is an electronic payment system based on cryptographic proof instead of trust, allowing any two willing parties to transact directly with each other without the need for a trusted third party. Transactions that are computationally impractical to reverse would protect sellers from fraud, and routine escrow mechanisms could easily be implemented to protect buyers. In this paper, we propose a solution to the double-spending problem using a peer-to-peer distributed timestamp server to generate computational proof of the chronological order of transaction. The system is secure as long as honest nodes collectively control more CPU power than any cooperationg group of attacker nodes.", "code": false},
                {"line": "2. Transactions", "code": false},
                {"line": "We define an electronic coin as a chain of digital signatures. Each owner transfers the coin to the next by digitally signing a hash of the previous transaction and the public key of the next owner and adding these to the end of the coin. A payee can verify the signatures to verify the chain of ownership.", "code": false},
                {"line": "The problem of course is the payee can't verify that one of the owners did not double-spend the coin. A common solution is to introduce a trusted central authority, or mint, that checks every transaction for double spending. After each transaction, the coin must be returned to the mint to issue a new coin, and only coins issued directly from the mint are trusted not to be double-spent. The problem with this solution is that the fate of the entire money system depends on the company running the mint, with every transaction having to go through them, just like a bank.", "code": false},
                {"line": "We need a way for the payee to know that the previous owners did not sign any earlier transactions. For our purposes, the earliest transaction is the one that counts, so we don't care about later attempts to double-spend. The only way to confirm the abscence of a transaction is to be aware of all transactions. In the mint based model, the mint was aware of all transactions and decided which arrived first. To accomplish this without a trusted party, transactions must be publicly announced [1], and we need a system for participants to agree on a single history of the order in which they were received. The payee needs proof that at the time of each transaction, the majority of nodes agreed it was the first received.", "code": false},
                {"line": "3. Timestamp Server", "code": false},
                {"line": "The solution we propse begins with a timestamp server. A timestamp server works by taking a hash of block of items to be timestamped and widely publishing the hash, such as in a newspaper or Usenet post [2-5]. The timestamp proves that the data must have existed at the time, obviously, in order to get into the hash. Each timestamp includes the previous timestamp in its hash, forming a chain, with each additional timestamp reinforcing the ones before it.", "code": false},
                {"line": "4. Proof-of-Work", "code": false},
                {"line": "To implement a distributed timestamp server on a peer-to-peer basis, we will need to use a proof-of-work system similar to Adam Back's Hashcash [6], rather than newspaper or Usenet posts. The proof-of work involves scanning for a value that when hashed, such as with SHA-256, the hash begins with a number of zero bits. The avarage work required is exponential in the number of zero bits required and can be verified by executing a single hash.", "code": false},
                {"line": "For our timestamp network, we implement the proof-of-work by incrementing a nonce in the block until a value is found that gives the block's hash the required zero bits. Once the CPU effort has been expended to make it satisfy the proof-of-work, the block cannot be changed without redoing the work. As later blocks are chained after it, the work to change the block would include redoing all the block after it.", "code": false},
                {"line": "The proof-of-work also solves the problem of determining representation in majority decision making. If the majority were based on one-IP-address-one-vote, it could be subverted by anyone able to allocate many IPs. Proof-of-work is essentially one-CPU-one-vote. The majority decision is represented by the longest chain, which has the greatest proof-of-work effort invested in it. If a majority of CPU power is controlled by honest nodes, the honest chain will grow the fastest and outpace any competing chains. To modify a past block, an attacker would have to redo the proof-of-work of the block and all blocks after it and then catch up with and surpass the work of the honest nodes. We will show later that the probability of a slower attacker catching up diminishes exponentially as subsequent blocks are added.", "code": false},
                {"line": "To compensate for increasing hardware speed and varying interest in running nodes over time, the proof-of-work difficulty is determined by a moving average targeting an average number of blocks per hour. If they're generated too fast, the difficulty increases.", "code": false},
                {"line": "5. Network", "code": false},
                {"line": "The steps to run the network are as follows:", "code": false},
                {"line": "1) New transactions are broadcast to all nodes.", "code": false},
                {"line": "2) Each node collects new transactions into a block.", "code": false},
                {"line": "3) Each node works on finding a difficult proof-of-work for its block.", "code": false},
                {"line": "4) When a node finds a proof-of-work, it broadcasts the block to all nodes.", "code": false},
                {"line": "5) Nodes accept the block only if all transactions in it are valid and not already spent.", "code": false},
                {"line": "6) Nodes express their acceptance of the block by working on creating the next block in the chain, using the hash of the accepted block as the previous hash.", "code": false},
                {"line": "Nodes always consider the longest chain to be the correct one and will keep working on extending it. If two nodes broadcast different versions of the next block simultaneously, some nodes may receive one or the other first. In that case, they work on the first one they received, but save the other branch in case it becomes longer. The tie will be broken when the next proofof-work is found and one branch becomes longer; the nodes that were working on the other branch will then switch to the longer one.", "code": false},
                {"line": "New transaction broadcasts do not necessarily need to reach all nodes. As long as they reach many nodes, they will get into a block before long. Block broadcasts are also tolerant of dropped messages. If a node does not receive a block, it will request it when it receives the next block and realizes it missed one", "code": false},
                {"line": "6. Incentive", "code": false},
                {"line": "By convention, the first transaction in a block is a special transaction that starts a new coin owned by the creator of the block. This adds an incentive for nodes to support the network, and provides a way to initially distribute coins into circulation, since there is no central authority to issue them. The steady addition of a constant of amount of new coins is analogous to gold miners expending resources to add gold to circulation. In our case, it is CPU time and electricity that is expended.", "code": false},
                {"line": "The incentive can also be funded with transaction fees. If the output value of a transaction is less than its input value, the difference is a transaction fee that is added to the incentive value of the block containing the transaction. Once a predetermined number of coins have entered circulation, the incentive can transition entirely to transaction fees and be completely inflation free.", "code": false},
                {"line": "The incentive may help encourage nodes to stay honest. If a greedy attacker is able to assemble more CPU power than all the honest nodes, he would have to choose between using it to defraud people by stealing back his payments, or using it to generate new coins. He ought to find it more profitable to play by the rules, such rules that favour him with more new coins than everyone else combined, than to undermine the system and the validity of his own wealth.", "code": false},
                {"line": "7. Reclaiming Disk Space", "code": false},
                {"line": "Once the latest transaction in a coin is buried under enough blocks, the spent transactions before it can be discarded to save disk space. To facilitate this without breaking the block's hash, transactions are hashed in a Merkle Tree [7][2][5], with only the root included in the block's hash. Old blocks can then be compacted by stubbing off branches of the tree. The interior hashes donot need to be stored.", "code": false},
                {"line": "A block header with no transactions would be about 80 bytes. If we suppose blocks are generated every 10 minutes, 80 bytes * 6 * 24 * 365 = 4.2MB per year. With computer systems typically selling with 2GB of RAM as of 2008, and Moore's Law predicting current growth of 1.2GB per year, storage should not be a problem even if the block headers must be kept in memory.", "code": false},
                {"line": "8. Simplified Payment Verification", "code": false},
                {"line": "It is possible to verify payments without running a full network node. A user only needs to keep a copy of the block headers of the longest proof-of-work chain, which he can get by querying network nodes until he's convinced he has the longest chain, and obtain the Merkle branch linking the transaction to the block it's timestamped in. He can't check the transaction for himself, but by linking it to a place in the chain, he can see that a network node has accepted it, and blocks added after it further confirm the network has accepted it.", "code": false},
                {"line": "As such, the verification is reliable as long as honest nodes control the network, but is more vulnerable if the network is overpowered by an attacker. While network nodes can verify transactions for themselves, the simplified method can be fooled by an attacker's fabricated transactions for as long as the attacker can continue to overpower the network. One strategy to protect against this would be to accept alerts from network nodes when they detect an invalid block, prompting the user's software to download the full block and alerted transactions to confirm the inconsistency. Businesses that receive frequent payments will probably still want to run their own nodes for more independent security and quicker verification", "code": false},
                {"line": "9. Combining and Splitting Value", "code": false},
                {"line": "Although it would be possible to handle coins individually, it would be unwieldy to make a separate transaction for every cent in a transfer. To allow value to be split and combined, transactions contain multiple inputs and outputs. Normally there will be either a single input from a larger previous transaction or multiple inputs combining smaller amounts, and at most two outputs: one for the payment, and one returning the change, if any, back to the sender. ", "code": false},
                {"line": "It should be noted that fan-out, where a transaction depends on several transactions, and those transactions depend on many more, is not a problem here. There is never the need to extract a complete standalone copy of a transaction's history", "code": false},
                {"line": "10. Privacy", "code": false},
                {"line": "The traditional banking model achieves a level of privacy by limiting access to information to the parties involved and the trusted third party. The necessity to announce all transactions publicly precludes this method, but privacy can still be maintained by breaking the flow of information in another place: by keeping public keys anonymous. The public can see that someone is sending an amount to someone else, but without information linking the transaction to anyone. This is similar to the level of information released by stock exchanges, where the time and size of individual trades, the \"tape\", is made public, but without telling who the parties were", "code": false},
                {"line": "As an additional firewall, a new key pair should be used for each transaction to keep them from being linked to a common owner. Some linking is still unavoidable with multi-input transactions, which necessarily reveal that their inputs were owned by the same owner. The risk is that if the owner of a key is revealed, linking could reveal other transactions that belonged to the same owner.", "code": false},
                {"line": "11. Calculations", "code": false},
                {"line": "We consider the scenario of an attacker trying to generate an alternate chain faster than the honest chain. Even if this is accomplished, it does not throw the system open to arbitrary changes, such as creating value out of thin air or taking money that never belonged to the attacker. Nodes are not going to accept an invalid transaction as payment, and honest nodes will never accept a block containing them. An attacker can only try to change one of his own transactions to take back money he recently spent.", "code": false},
                {"line": "The race between the honest chain and an attacker chain can be characterized as a Binomial Random Walk. The success event is the honest chain being extended by one block, increasing its lead by +1, and the failure event is the attacker's chain being extended by one block, reducing the gap by -1.", "code": false},
                {"line": "The probability of an attacker catching up from a given deficit is analogous to a Gambler's Ruin problem. Suppose a gambler with unlimited credit starts at a deficit and plays potentially an infinite number of trials to try to reach breakeven. We can calculate the probability he ever reaches breakeven, or that an attacker ever catches up with the honest chain, as follows [8]:", "code": false},
                {"line": "p = probability an honest node finds the next block", "code": false},
                {"line": "q = probability the attacker finds the next block", "code": false},
                {"line": "qz = probability the attacker will ever catch up from z blocks behind", "code": false},
                {"line": "equasion", "code": false, "math": true, "inline": false},
                {"line": "Given our assumption that p > q, the probability drops exponentially as the number of blocks the attacker has to catch up with increases. With the odds against him, if he doesn't make a lucky lunge forward early on, his chances become vanishingly small as he falls further behind.", "code": false},
                {"line": "We now consider how long the recipient of a new transaction needs to wait before being sufficiently certain the sender can't change the transaction. We assume the sender is an attacker who wants to make the recipient believe he paid him for a while, then switch it to pay back to himself after some time has passed. The receiver will be alerted when that happens, but the sender hopes it will be too late.", "code": false},
                {"line": "The receiver generates a new key pair and gives the public key to the sender shortly before signing. This prevents the sender from preparing a chain of blocks ahead of time by working on it continuously until he is lucky enough to get far enough ahead, then executing the transaction at that moment. Once the transaction is sent, the dishonest sender starts working in secret on a parallel chain containing an alternate version of his transaction.", "code": false},
                {"line": "The recipient waits until the transaction has been added to a block and z blocks have been linked after it. He doesn't know the exact amount of progress the attacker has made, but assuming the honest blocks took the average expected time per block, the attacker's potential progress will be a Poisson distribution with expected value:", "code": false},
                {"line": "=z q p", "code": false, "math": true, "inline": false},
                {"line": "To get the probability the attacker could still catch up now, we multiply the Poisson density for each amount of progress he could have made by the probability he could catch up from that point:", "code": false},
                {"line": "∑", "code": false, "math": true, "inline": false},
                {"line": "Rearranging to avoid summing the infinite tail of the distribution...", "code": false},
                {"line": "∑", "code": false},
                {"line": "Converting to C code...", "code": false},
                {"line": "#include <math.h>", "code": true},
                {"line": "double AttackerSuccessProbability(double q, int z)", "code": true},
                {"line": "{", "code": true},
                {"line": "    double p = 1.0 - q;", "code": true},
                {"line": "    double lambda = z * (q / p);", "code": true},
                {"line": "    double sum = 1.0;", "code": true},
                {"line": "    int i, k;", "code": true},
                {"line": "    for (k = 0; k <= z; k++)", "code": true},
                {"line": "    {", "code": true},
                {"line": "       double poisson = exp(-lanbda);", "code": true},
                {"line": "       for (i = 1; i <= k; i++)", "code": true},
                {"line": "          poisson *= lambda / i; ", "code": true},
                {"line": "       sum -= poisson * (1 - pow(q / p, z - k));", "code": true},
                {"line": "    }", "code": true},
                {"line": "    return sum;", "code": true},
                {"line": "}", "code": true},
                {"line": "Running some results, we can see the probability drop off exponentially with z.", "code": false},
                {"line": "q=0/1", "code": true},
                {"line": "z=0    P=1.0000000", "code": true},
                {"line": "z=1    P=0.2045873", "code": true},
                {"line": "z=2    P=0.0509779", "code": true},
                {"line": "z=3    P=0.0131722", "code": true},
                {"line": "z=4    P=0.0034552", "code": true},
                {"line": "z=5    P=0.0009137", "code": true},
                {"line": "z=6    P=0.0002428", "code": true},
                {"line": "z=7    P=0.0000647", "code": true},
                {"line": "z=8    P=0.0000173", "code": true},
                {"line": "z=9    P=0.0000046", "code": true},
                {"line": "z=10   P=0.0000012", "code": true},
                {"line": "q=0.3", "code": true},
                {"line": "z=0    P=1.0000000", "code": true},
                {"line": "z=5    P=0.1773523", "code": true},
                {"line": "z=10    P=0.0416605", "code": true},
                {"line": "z=15    P=0.0101008", "code": true},
                {"line": "z=20    P=0.0024804", "code": true},
                {"line": "z=25    P=0.0006132", "code": true},
                {"line": "z=30    P=0.0001522", "code": true},
                {"line": "z=35    P=0.0000379", "code": true},
                {"line": "z=40    P=0.0000095", "code": true},
                {"line": "z=45    P=0.0000024", "code": true},
                {"line": "z=50    P=0.0000006", "code": true},
                {"line": "Solving for P less than 0.1%...", "code": false},
                {"line": "P < 0.001", "code": true},
                {"line": "q=0.10    z=5", "code": true},
                {"line": "q=0.15    z=8", "code": true},
                {"line": "q=0.20    z=11", "code": true},
                {"line": "q=0.25    z=15", "code": true},
                {"line": "q=0.30    z=24", "code": true},
                {"line": "q=0.35    z=41", "code": true},
                {"line": "q=0.40    z=89", "code": true},
                {"line": "q=0.45    z=340", "code": true},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false}
            ],
            "postTags": "",
            "id": 1
        },
        {
            "postTitle": "How do cryptocurrencies work? What is blockchain technology?",
            "postLines": [
                {"line": "Cryptocurrencies - what is it?", "code": false},
                {"line": "Many people will be tempted to call cryptocurrencies digital money. Most of all, due to the fact that they can perform a payment function. However, the truth is that it is not a currency in the strict sense. Completely different mechanisms are at work here. It is definitely better to consider cryptocurrencies as a form of investing money. Especially since most of the buying and selling takes place on the stock market. Many people decide to buy cryptocurrencies in exchange offices for cryptocurrencies, which provide the service of buying and selling digital currencies, including the most popular bitcoin. Cryptocurrencies exist only in virtual form. Their price, as it happens on the stock exchange, is the result of free market mechanisms, determined by the current demand and supply.", "code": false},
                {"line": "how cryptocurrencies were created?", "code": false},
                {"line": "Probably the explanation that cryptocurrencies are virtual funds in which you can invest is not enough to understand what they are and what their principle of operation is. So it's worth going back to the moment of their creation. In 2008, Satoshi Nakamoto (programmer or group of developers) published his manifesto, which was the inauguration of bitcoin. It was titled: \"Bitcoin: A peer-to-peer electronic money system.\" It was from the manifest that it was possible to find out how cryptocurrency works, so an explanation of blockchain technology was included. What is this? How does it matter?", "code": false},
                {"line": "Blockchain technology - how to understand it?", "code": false},
                {"line": "In principle, most cryptocurrencies use the same technology. So they function in a similar way. The entire mechanics of their operation is based on a decentralized system. It is the one of the main ideas of blockchain technology. Blockchain, literally translated, means \"a chain of blocks\" and it is a perfect pictorial representation of the issue.", "code": false},
                {"line": "How should blockchain be understood?", "code": false},
                {"line": "It is a technology that allows data to be stored using a cryptographic chain. Because this information is retrieved, verified, and encrypted using complex mathematical calculations, it is secure. Moreover, it is impossible to counterfeit both cryptocurrencies and the operations they participate in. It is worth knowing that in blockchain technology, information is not stored in one database, but is dispersed among many network users. Often the calculations (in the case of proof-of-work) also take place on their computers, using their computing power. Of course they get paid for it.", "code": false},
                {"line": "However, this should not be understood as intermediary process. Blockchain technology works directly between the sending and receiving parties. However, that's not all there is to know. In blockchain technology, the parties to the transaction only have the necessary details about them, although both the accounting register and the basic data for the operation are publicly available. Blockchain is a public record for everyone. This is the data that is placed in the blocks.", "code": false},
                {"line": "Each subsequent one is built on the basis of the previous one and contains information linking it to the next one. In this way, they create the aforementioned \"blockchain\". Thus, in the case of a blockchain, once entered data cannot be deleted or modified", "code": false},
                {"line": "It is worth knowing that this technology can also be used for other purposes, just like digital currencies can be implemented without a blockchain. The truth is, however, that it offers amazing technical benefits. This is why today the world's cryptocurrencies that are traded are based on blockchains.", "code": false}
            ],
            "postTags": "Blockchain, Crypto, Cryptocurrencies, Bitcoin, Satoshi Nakamoto",
            "id": 2
        },
        {
            "postTitle": "Will the act on artificial intelligence protect us from the invasion of robots and the annihilation of humanity?",
            "postLines": [
                {"line": "\"In April 2021, the European Commission presented a very important legislative project - the Artificial Intelligence (AIA) Act, which is intended to establish a strong framework for human protection in the era of artificial intelligence. It also has other goals, such as promoting innovation through the so-called regulatory sandboxes or facilitations for entities from the SME sector, but the foundation is indeed a human being and fundamental rights and values. AIA has undergone a major evolution over the last two years, all due to unclear or too general terms and sometimes unrealistic assumptions that would prevent the implementation of appropriate solutions by the addressees of specific requirements.", "code": false},
                {"line": "In the meantime, other acts have appeared, such as the European Data Governance Act, the Data Act and the Digital Single Market Regulation. (...) it is worth knowing that the legal framework in this area is subject to very dynamic changes. Each of these legal acts - in its own way - is to protect us against the risks that artificial intelligence may generate.", "code": false},
                {"line": "Well, is this really about artificial intelligence? AIA itself uses the term not so much artificial intelligence as artificial intelligence systems, which – in simple terms – we treat as software or a system, a protocol or a set of instructions, developed by a man and in order to perform a task defined by him, although with the use of techniques and approaches that can be evidence of (seeming) autonomy, i.e. machine learning or deep learning. These systems have been classified according to the level of risk generated, and such classification is to be associated with specific obligations on the part of individual 'actors' of the life cycle of such a system.", "code": false},
                {"line": "The classification is relatively simple, although in each of the subsequent iterations there are certain 'flavors' aimed at specifying the expectations of the EU legislator. So, as originally proposed, we have artificial intelligence systems that will be banned; high-risk systems (quite wide catalogue); systems with an increased level of transparency and others. One of the latest proposals assumes the introduction of the concept of general-purpose systems, e.g. ChatGPT, Google Translate or systems for creating 'deep fakes', which will probably constitute the fifth category, however, similar to high-risk systems.", "code": false},
                {"line": "If we take a closer look at this classification, we will see that the prohibited practices include systems used by the public sector for the so-called social scoring or identification of citizens in public space (with exceptions) and those used by the private sector, such as systems that manipulate people, e.g. using their weaknesses or subliminal techniques. In turn, the high-risk ones are associated with the risk of violating the fundamental rights contained in the Charter of Fundamental Rights and we will find there, among others: systems for assessing job candidates, biometric identification systems or some solutions in the field of judiciary and prevention. These systems will entail specific – quite significant – obligations, the failure to comply with which will entail the risk of imposing an administrative sanction, which is to be quite - financially - severe.", "code": false},
                {"line": "And finally, the third category, which is to be related to the need to inform a person about the interaction not with another person, but with an 'automaton'. Chatbots, videobots or voice assistants, this is what the AIA draws attention to in the context of transparency.", "code": false},
                {"line": "At this point, let's return to the title question - will the act on artificial intelligence protect us from the invasion of robots and the destruction of humanity? That's not what the AIA is about. Rather, the aim is to impose some high standards on developers, operators and users of systems, who will have to pay more attention to what they design, deliver and use. Assuming that in the foreseeable future we will not be able to create an autonomous and, above all, conscious artificial intelligence system, we must protect ourselves from others. Unfortunately.", "code": false},
                {"line": "AIA imposes strict requirements and restrictions, which, however, are aimed at ensuring supervision, risk management, such as algorithmic bias (bias), high-quality data or the use of innovative solutions as intended and for the benefit of man. Regulations alone will not eliminate the risks associated with the improper or ethical use of such systems. Harm (economic, physical or psychological) and damages will also accompany us in the context of AI systems. The Union is working intensively to define clear rules in this area as well. One way or another, it will still be something for which man will be responsible. After all, today no one seriously thinks about granting legal personality to 'robots'. It is man who stands behind the system and it depends only on him whether it will serve humanity or become another obstacle for it, or even a 'small' destruction.\"", "code": false}
            ],
            "postTags": "AI, Artificial, Inteligence, Machine Learning, Data Science",
            "id": 3
        },
        {
            "postTitle": "Feedfowrward Neural Networks and their Creation in Python",
            "postLines": [
                {"line": "Today we will try to understand the operation of Feedforward neural networks, by constructing a simple example of such a network in Python.", "code": false},
                {"line": "Even though Machine Learning's mathematical engine is a complex concept to comprehend, in today's example only the ability to multiply matrices is required to grasp the idea.", "code": false},
                {"line": "If you ever want to go into Machine Learning industry, learning statistics would be a wise choice for setting your knowlege base as a neural network is a statistical computational model. You can think of it as a system of neurons connected by synapses that send impulses (data) to each other. Data travels across these synapses - from one layer to another. A simple neural network is build upon three layers: the input layer, the hidden layer, and the output layer, as shown below, on the Diagram.", "code": false},
                {"line": "Layers Diagram", "code": false, "image": true, "image_id": 4.0},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false}
            ],
            "postTags": "",
            "id": 4.0
        },
        {
            "postTitle": "SaaS?",
            "postLines": [
                {"line": "Software as a service, or SaaS in short,  a software sharing model that has gained immense popularity in recent years. To a large extent, this is due to the continuous development of cloud technologies and the greater opportunities that subsequent innovations in this area give to the creators of computer programs. Even if you've never heard of SaaS, you probably still use the applications provided in this model every day.", "code": false},
                {"line": "It is a model of distribution of computer applications, with clients having acces to the tool they need only via Internet. The application uses the public cloud infrastructure for efficient operation, where its resources are also stored.", "code": false},
                {"line": "The SaaS model is now widely used both in business and in the private sector. Every day, many users use e-mail boxes, cloud drives and ubiquitous websites that provide libraries of movies, music or books.", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false}
            ],
            "postTags": "",
            "id": 5
        },
        {
            "postTitle": "",
            "postLines": [
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false}
            ],
            "postTags": "",
            "id": 6
        }
    ],
    "javascript" : [
        {
            "postTitle": "Assigning values of one object onto another.",
            "postLines": [
                {"line": "var objA = {", 
                "code": true},
                {"line": "   age: '8',", "code": true},
                {"line": "   city: 'Porto'", "code": true},
                {"line": "};", "code": true},
                {"line": "var objB ={", "code": true},
                {"line": "   age: '6',", "code": true},
                {"line": "   city: 'Paris',", "code": true},
                {"line": "   experience: '1'", "code": true},
                {"line": "};", "code": true},
                {"line": "var objC =", "code": true},
                {"line": "Object.assign({}, objA, objB);", "code": true},
                {"line": "", "code": false},
                {"line": "output: ", "code": false},
                {"line": "{age: '6',", "code": true},
                {"line": " city: 'Paris',", "code": true},
                {"line": " experience: '1'}", "code": true}
            ],
            "postTags": "object, Object.assign(), copying objects",
            "id": 1
        },
        {
            "postTitle": "The switch statement.",
            "postLines": [
                {"line": "var day = 7;", "code": true},
                {"line": "switch(day){", "code": true},
                {"line": "   case 1:", "code": true},
                {"line": "      document.write('Mon');", "code": true},
                {"line": "      break;", "code": true},
                {"line": "   case 2:", "code": true},
                {"line": "      document.write('Tue');", "code": true},
                {"line": "      break;", "code": true},
                {"line": "   case 3:", "code": true},
                {"line": "      document.write('Wed');", "code": true},
                {"line": "      break;", "code": true},
                {"line": "   case 4:", "code": true},
                {"line": "      document.write('Thu');", "code": true},
                {"line": "      break;", "code": true},
                {"line": "   case 5:", "code": true},
                {"line": "      document.write('Fri');", "code": true},
                {"line": "      break;", "code": true},
                {"line": "   case 6:", "code": true},
                {"line": "      document.write('Sat');", "code": true},
                {"line": "      break;", "code": true},
                {"line": "   case 7:", "code": true},
                {"line": "      document.write('Sun');", "code": true},
                {"line": "Output: Sun", "code": false}
            ],
            "postTags": "switch, break, document.write()",
            "id": 2
        },
        {
            "postTitle": " Looping over a Map() object.",
            "postLines": [
                {"line": "let zoo = new Map();", "code": true},
                {"line": "", "code": true},
                {"line": "zoo.set('Zebra', 5);", "code": true},
                {"line": "zoo.set('Gorilla', 2);", "code": true},
                {"line": "zoo.set('Monkey', 76);", "code": true},
                {"line": "", "code": true},
                {"line": "console.log(zoo);", "code": true},
                {"line": "", "code": true},
                {"line": "let zebraCount = zoo.get('Zebra');", "code": true},
                {"line": "console.log(zebraCount);", "code": true},
                {"line": "", "code": true},
                {"line": "for (let[key, value] of zoo) {", "code": true},
                {"line": "  console.log(key + ':' + value)", "code": true},
                {"line": "}", "code": true},
                {"line": "", "code": false},
                {"line": "output:", "code": false},
                {"line": "Map() {'Zebra' => 5, 'Gorilla' => 2, 'Monkey' => 76}", "code": false},
                {"line": "5", "code": false}
            ],
            "postTags": "Map() object, Map.get(), key and value of Map()",
            "id": 3
        },
        {
            "postTitle": " Map() Object in JavaScript",
            "postLines": [
                {"line": "Since EcmaScript 6 we have new classes, which can facilitate working with collections. Map and WeakMap are just two of these classes.", "code": false},
                {"line": "All objects in JavaScript can be looked at as we do at Map() objects. An Object, in summary, consists of properties and values. We could think of them like of keys and values.", "code": false},
                {"line": "", "code": true},
                {"line": "var obj = new Object();", "code": true},
                {"line": "obj.a = 1;", "code": true},
                {"line": "obj.b = 2;", "code": true},
                {"line": "obj[0] = 3;", "code": true},
                {"line": "", "code": false},
                {"line": "console.log(obj['a']);", "code": true},
                {"line": "console.log(obj['b']);", "code": true},
                {"line": "console.log(obj[0]);", "code": true},
                {"line": "", "code": false},
                {"line": "console.log(obj);", "code": true},
                {"line": "", "code": false},
                {"line": "Output:", "code": false},
                {"line": "1", "code": true},
                {"line": "2", "code": true},
                {"line": "3", "code": true},
                {"line": "{0: 3, a: 1, b: 2}", "code": true},
                {"line": "", "code": false},
                {"line": "The below more advanced example treats the whole object as a key.", "code": false},
                {"line": "", "code": false},
                {"line": "var obj = new Object();", "code": true},
                {"line": "var objKey = ({id: 1});", "code": true},
                {"line": "obj[objKey] = 4;", "code": true},
                {"line": "console.log(obj[objKey]);", "code": true},
                {"line": "console.log(Object", "code": true},
                {"line": ".getOwnPropertyNames(obj));", "code": true},
                {"line": "", "code": false},
                {"line": "Output:", "code": false},
                {"line": "4", "code": true},
                {"line": "['[object Object]']", "code": true},
                {"line": "Which seems a bit odd due to the ['[object Object]'] index.", "code": false},
                {"line": "", "code": false},
                {"line": "As we can see a JavaScript object cannot be treated as a dictionary.", "code": false},
                {"line": "And this is the reason to use the classes Map and WeakMap. So, what makes the WeakMap class so weak?", "code": false},
                {"line": "Let's assume, that an object as a key in WeakMap exists. Later all references to this object in JavaScript disappear at some point. JavaScript engine will remove the references from WeakMap.", "code": false},
                {"line": "Meaning WeakMap does not remember this object strongly. When object are to be cleared, then these will be automatically removed from WeakMap. Keys in WeakMap are not permanent. It is one of the reasons why we don't perform iterations over keys of WeakMap and showing all the variables stored in WeakMap can prove cumbersome.", "code": false},
                {"line": "Below we have an example of an ordinary map. We create keys which are of object type and set their values. In the next step we try to get a specified value.", "code": false},
                {"line": "let user1 = {name: 'Cesar'};", "code": true},
                {"line": "let user2 = {name: 'Kate'};", "code": true},
                {"line": "", "code": false},
                {"line": "let users = new Map();", "code": true},
                {"line": "users.set(user1, 'Designer');", "code": true},
                {"line": "users.set(user2, 'Developer');", "code": true},
                {"line": "", "code": false},
                {"line": "console.log(users.get(user1));", "code": true},
                {"line": "Output: Designer", "code": false}



            ],
            "postTags": "",
            "id": 4
        },
        {
            "postTitle": " Post",
            "postLines": [
                {"line": "", "code": false},
                {"line": "", "code": true}
            ],
            "postTags": "",
            "id": 5
        },
        {
            "postTitle": " Post",
            "postLines": [
                {"line": "", "code": false},
                {"line": "", "code": true}
            ],
            "postTags": "",
            "id": 6
        }
    ],
    "python" : [
        {
            "postTitle": "Python Syntax",
            "postLines": [
                {"line": "Python syntax or any programming language syntax is a set of rules to be followed in order for our code to be well understandable and executed in the way we intend it to work.", "code": false},
                {"line": "print(2+4)", "code": true},
                {"line": "Output: 6", "code": true},
                {"line": "Addition of floats returns a floating point number (float).", "code": false},
                {"line": "print(2.0 + 5.111)", "code": true},
                {"line": "Output: 7.111", "code": true},
                {"line": "Adding an integer and a float will include the value after the point of the float returning a float.", "code": false},
                {"line": "print(6 + 7.111)", "code": true},
                {"line": "Output: 13.111", "code": true},
                {"line": "print(2 + 5.0)", "code": true},
                {"line": "Output: 7.0 #Instead of 7.", "code": true}
            ],
            "postTags": "",
            "id": 1.03
        },
        {
            "postTitle": "Numbers - Integers and Floats",
            "postLines": [
                {"line": "Integers are whole numbers, floats are also numbers, but hold a value after the point which can be zero as well, e.g. 2.0 or 5.111.", "code": false},
                {"line": "Addition of integers returns an integer.", "code": false},
                {"line": "print(2+4)", "code": true},
                {"line": "Output: 6", "code": true},
                {"line": "Addition of floats returns a floating point number (float).", "code": false},
                {"line": "print(2.0 + 5.111)", "code": true},
                {"line": "Output: 7.111", "code": true},
                {"line": "Adding an integer and a float will include the value after the point of the float returning a float.", "code": false},
                {"line": "print(6 + 7.111)", "code": true},
                {"line": "Output: 13.111", "code": true},
                {"line": "print(2 + 5.0)", "code": true},
                {"line": "Output: 7.0 #Instead of 7.", "code": true}
            ],
            "postTags": "",
            "id": 1.09
        },
        {
            "postTitle": "Types - determining the type of a variable",
            "postLines": [
                {"line": "Determining the type of a variable", "code": false},
                {"line": "print(2+4)", "code": true},
                {"line": "Output: 6", "code": true},
                {"line": "Addition of floats returns a floating point number (float).", "code": false},
                {"line": "print(2.0 + 5.111)", "code": true},
                {"line": "Output: 7.111", "code": true},
                {"line": "Adding an integer and a float will include the value after the point of the float returning a float.", "code": false},
                {"line": "print(6 + 7.111)", "code": true},
                {"line": "Output: 13.111", "code": true},
                {"line": "print(2 + 5.0)", "code": true},
                {"line": "Output: 7.0 #Instead of 7.", "code": true}
            ],
            "postTags": "",
            "id": 1.01
        },
        {
            "postTitle": "Arrays - Basics",
            "postLines": [
                {"line": "Array is a sort of a box that contains values, usually separated by a comma. In Python those values can be of different type, unlike in C++, where the values must be of the same type.", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": true}
            ],
            "postTags": "",
            "id": 2.0
        },
        {
            "postTitle": "PyGym - Exercise 2.0",
            "postLines": [
                {"line": "Write a program that displays two arbitrary messages to the screen.", "code": false},
                {"line": "", "code": true}
            ],
            "postTags": "",
            "id": 2.0
        },
        {
            "postTitle": "PyGym - Exercise 2.1",
            "postLines": [
                {"line": "Write a program that asks the user for their name and year of birth, then calculates and prints their age.", "code": false},
                {"line": "Examplary execution:", "code": false},
                {"line": "Give your name:", "code": false},
                {"line": "Johnny", "code": false},
                {"line": "Enter year of birth:", "code": false},
                {"line": "1989", "code": false},
                {"line": "John, you are 30 years old.", "code": false}
            ],
            "postTags": "",
            "id": 2.1
        },
        {
            "postTitle": "PyGym Exercise 2.2",
            "postLines": [
                {"line": "Write a program that asks the user for their name and year of birth, then calculates and prints their age.", "code": false},
                {"line": "Examplary execution:", "code": false},
                {"line": "Give your name:", "code": false},
                {"line": "Johnny", "code": false},
                {"line": "Enter year of birth:", "code": false},
                {"line": "1989", "code": false},
                {"line": "John, you are 30 years old.", "code": false}
            ],
            "postTags": "",
            "id": 2.2
        },
        {
            "postTitle": "Working with Files in Python",
            "postLines": [
                {"line": "Reading and Writing to Files", "code": false},
                {"line": "The process of reading and writing data to a file is a complex task. Python, like most programming languages, allows for loading data from external sets and save data to files. The reading process can be carried out using the built-in functions open(), read() and close() or - in the case of data with a fixed structure - usually tabular, you can use ready-made functions supporting this process. First, we will analyze the process of reading data using built-in functions and then we will show an example of external solutions.", "code": false},
                {"line": "To read a text file, you need to execute three commands: ", "code": false},
                {"line": "open() to connect to the file (nothing is loaded)", "code": false},
                {"line": "read() to read the entire contents of the file into one variable as text", "code": false},
                {"line": "close() to close the file after reading is complete", "code": false},
                {"line": "In addition, the reading or writing process requires finding the correct file, or - in the case of reading - creating a new file.", "code": false},
                {"line": "As an example, we'll load a small text file from the same directory as our script.", "code": false},
                {"line": "# -*- coding: utf -8 -*-", "code": true},
                {"line": "f = open('file.txt')", "code": true},
                {"line": "contents = f.read()", "code": true},
                {"line": "f.close()", "code": true},
                {"line": "contents", "code": true},
                {"line": "'This is the content of the file\nLine 2\nLine 3\n\nThere is an empty line above.\n'"},
                {"line": "The open() function connects to the file but does not load the data. It only assigns a file pointer to the object f. This is due to the fact that the data set can be very large and the programmer should keep control over its loading. The read() function reads all the content from source f(file) into the variable content. Then the source is closed.", "code": false},
                {"line": "The '\n' character within the variable means the end of the line, to break such a line into separate ones, use the split() function, indicating the character used for breaking.", "code": false},
                {"line": "contents.split('\n')", "code": true},
                {"line": "#Out: ['This is the content of the file',", "code": true},
                {"line": "'Line 2',", "code": true},
                {"line": "'Line 3',", "code": true},
                {"line": "'',", "code": true},
                {"line": "'There is an empty line above.'", "code": true},
                {"line": "'']", "code": true},
                {"line": "For large files, it is better to use a line-by-line reading procedure. Reading line by line is also an operation used when we want to read specific lines from a file:", "code": false},
                {"line": "f = open('file.txt')", "code": true},
                {"line": "f.readline()", "code": true},
                {"line": "f.readline()", "code": true},
                {"line": "f.readline()", "code": true},
                {"line": "f.close()", "code": true},
                {"line": "#Out: 'This is the content of the file\n'", "code": true},
                {"line": "Line 2\n", "code": true},
                {"line": "Line 3\n", "code": true},
                {"line": "This way we can control which lines are saved for further processing.", "code": false},
                {"line": "The open() function by default opens a text file for reading, thus calling open() is equivalent to open(file, 'rt'). Files can also be opened in other modes, such as binary mode ('b') or write mode ('w'), write and append mode ('a'), or create new file mode ('x').", "code": false},
                {"line": "Reading and Processing Tabular Files", "code": false},
                {"line": "Since Python loads data in the form of a single text variable, if we intend to calculate the loaded data, it should be appropriately transformed, usually in tabular form, and the data types should be modified from text to numeric. The already known split() and variable conversion functions are used for this purpose. The procedure for reading data is as follows:", "code": false},
                {"line": "1. In the first step, a connection to the file is established (the content is displayed).", "code": false},
                {"line": "2. The data is divided into a list of text strings, relative to the '\n' character, and then each line is divided into internal lists based on a comma (separator in csv). The result is displayed as a nested list.", "code": false},
                {"line": "3. The connection is closed.", "code": false},
                {"line": "4. 1 line (header) is removed from the list.", "code": false},
                {"line": "5. The last empty line is removed from the list (usually found in text files).", "code": false},
                {"line": "f = open('tab.csv') #1", "code": true},
                {"line": "data = f.read()", "code": true},
                {"line": "data", "code": true},
                {"line": "data = data.split('\n') #divide by lines", "code": true},
                {"line": "data = [l.split(',') for l in dane] #2", "code": true},
                {"line": "data", "code": true},
                {"line": "f.close() #3", "code": true},
                {"line": "header = data.pop(0) #4", "code": true},
                {"line": "data.pop() #5", "code": true},
                {"line": "Out: 'Street, House_no, code, city\nGrasshopers, 20, W1S L20, Grassfields\nLadybirds, 15, Z81 S22, Sunshines\nBeetles, 10, UL1 SW2, Beetlejuices\n'", "code": true},
                {"line": "Out: [['Street', 'House_no', 'code', 'city'],", "code": true},
                {"line": "      ['Grasshopers', ' 20', ' W1S L20', ' Grassfields'],", "code": true},
                {"line": "      ['Ladybirds', ' 15', ' Z81 S22', ' Sunshines'],", "code": true},
                {"line": "      ['Beetles', ' 10', ' UL1 SW2', ' Beetlejuices'],", "code": true},
                {"line": "      ['']]", "code": true},
                {"line": "Out: ['']", "code": true},
                {"line": "Data is stored as a list of lists, where each nested list is a single row of different types of data. Since it is not convenient to operate on rows containing different types of data, the nested lists can be transrormed into a columnar form (transposed) using the zip() function. The data is passed with *, i.e. we expand the passed list to the following form: data[0], data[1], ..., data[n-1].", "code": false},
                {"line": "data = zip(*data)", "code": true},
                {"line": "trans = list(data)", "code": true},
                {"line": "trans", "code": true},
                {"line": "Out: [('Grasshopers', 'Ladybirds', 'Beetles'),", "code": true},
                {"line": "      (' 20', ' 15', ' 10'),", "code": true},
                {"line": "      (' W1S L20', ' Z81 S22', ' UL1 SW2'),", "code": true},
                {"line": "      (' Grassfields', ' Sunshines', ' Beetlejuices')]", "code": true},
                {"line": "in the last step the second and third lines can be casted into integer type. Here, the mapping function comes in handy:", "code": false},
                {"line": "numbers = tuple(map(int, trans[1]))", "code": true},
                {"line": "numbers", "code": true},
                {"line": "Out: (20, 15, 10)", "code": true},
                {"line": "Using the csv reader Function", "code": false},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true}

            ],
            "postTags": "",
            "id": 4.0
        }
    ],
    "cpp" : [
        {
            "postTitle": "First C++ Program",
            "postLines": [
                {"line": "#include <iostream>", "code": true},
                {"line": "using namespace std;", "code": true},
                {"line": "int main()", "code": true},
                {"line": "{", "code": true},
                {"line": "   char a;", "code": true},
                {"line": "   cout << 'Cpp - Practical Exercises';", "code": true},
                {"line": "   cin >> a;", "code": true},
                {"line": "   return 0;", "code": true},
                {"line": "}", "code": true},
                {"line": "", "code": true}
            ],
            "postTags": "",
            "id": 2.1
        },
        {
            "postTitle": "Functions in C++",
            "postLines": [
                {"line": "Functions make our code more readable, less as they say 'like macaroni cheese'. They are separate parts of a program that perform specific tasks.", "code": false},
                {"line": "An example of using a function can be a program simulating the operation of a simple calculator. It performs operations such as addition, substraction, multiplication and division.", "code": false},
                {"line": "Each of these calculations can be separated from the main part of the program by enclosing them in four separate functions.", "code": false},
                {"line": "Function Structure", "code": false},
                {"line": "type of returned value name (list of types and names of arguments){", "code": true},
                {"line": "instructions;", "code": true},
                {"line": "}", "code": true},
                {"line": "Type of Returned Value", "code": false},
                {"line": "A function may but doesn't have to return a value in one of the forms known in Cpp, eg: int, float, char, string, bool. If, however, our function is not to return anything we simply implement a special 'void' type.", "code": false},
                {"line": "List of Types and Names of Arguments", "code": true},
                {"line": "We placethe argument list in the parentheses, after the function name. If the function is not to take any arguments, we leave the parentheses blank.", "code": false},
                {"line": "Example 1: ","code": false},
                {"line": "int addition (int first, int second) {", "code": true},
                {"line": "   int result = first + second;", "code": true},
                {"line": "   return result;", "code": true},
                {"line": "The above function accepts two arguments of type int named 'first'and 'second'. The returned value is the sum of these two."}

            ]
        },
        {
            "postTitle": "While Loop",
            "postLines": [
                {"line": "The while loop is something between a for loop and a do while loop and can also be a means to translate an if statement into a shorter form. It's main feature in common with the for loop is the condition being checked at the beginning of the loop, meaning that it does not necessarily run at all. On the other hand the do while loop runs at least once, if the condition is realistic in current settings.", "code": false},
                {"line": "The while loop, like the for loop and the do while loop, allows for repetition of a statement as long as the end condition is met. Semantically, the while loop can be written as follows:", "code": false},
                {"line": "while(end condition)", "code": true},
                {"line": "{statement list}", "code": true},
                {"line": "First of all, the condition is written at the very beginning of the loop and so it is checked before anything else is executed, and that way if the condition is not fulfilled, nothing is done.", "code": false},
                {"line": "It is worth noting that the curly braces are not required when we want to execute only one statement, whereas in the do while loop, braces are required even for only one statement.", "code": false},
                {"line": "Another thing to remember is that there is no semicolon after the curly braces, whereas in the case of the do while loop, the semicolon is there.", "code": false},
                {"line": "Simple examples of using the while loop:", "code": false},
                {"line": "#include <iostream>", "code": true},
                {"line": "using namespace std;", "code": true},
                {"line": "int main()", "code": true},
                {"line": "{", "code": true},
                {"line": "  int how_many = 6;", "code": true},
                {"line": "  while(how_many)", "code": true},
                {"line": "    cout << 'I am inside the while loop' << endl;", "code": true},
                {"line": "  cout << endl << 'Press Enter to finish.' << endl;", "code": true},
                {"line": "  getchar();     #Returns the code of the read character in case of success. The read character is returned in form of an int.", "code": true},
                {"line": "  return 0;", "code": true},
                {"line": "}", "code": true},
                {"line": "Run the above program to see that none of the inside statements get executed. Can you guess why?", "code": false},
                {"line": "And here is another example of a problematic program:", "code": false},
                {"line": "#include <iostream>", "code": true},
                {"line": "using namespace std;", "code": true},
                {"line": "int main()", "code": true},
                {"line": "{", "code": true},
                {"line": "  int how_many = 4;", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true}
            ],
            "postTags": "",
            "id": 3.1
        }
    ],
    "data_science" : [
        {
            "postTitle": "Data Science Terminology - Statistical learning",
            "postLines": [
                {"line": "Statistical learning, also known as machine learning, is a field of study that focuses on developing algorithms and techniques to enable computers to learn from and make predictions or decisions based on data. In statistical learning, we use mathematical and statistical methods to analyze and interpret patterns and relationships in data, with the goal of creating models that can generalize well to new, unseen data.", "code": false},
                {"line": "There exist two main types of statistical learning approaches:", "code": false},
                {"line": "'Supervised Learning' in which the algorithm is trained on labeled data, where each example is associated with a target or outcome variable. The algorithm learns from the input-output pairs in the training data and aims the generalize its predictions to new, unseen data. Common tasks in supervised learning include classification (predicting categories or classes) and regression (predicting continuous values).", "code": false},
                {"line": "'Unsupervised Learning' in which the algorithm is trained on unlabeled data, where there are no predefined target variables. The goal of unsupervised learning is to uncover hidden patterns, structures, or relationships in the data. Common tasks in unsupervised learning include clustering (grouping similar data points together) and dimensionality reduction (reducing the number of features or variables while preserving important information).", "code": false},
                {"line": "Statistical learning techniques are used in a wide range of applications, including image and speech recognition, natural language processing, recommandation systems, financial modeling, and many others. The field continues to advance rapidly, driven by innovations in algorithms, computational power, and the availability of large datasets.", "code": false}
                
            ],
            "postTags": "",
            "id": 0.00
        },
        {
            "postTitle": "Data Science Terminology - Continuous vs Quantitative Output Values",
            "postLines": [
                {"line": "In statistical learning or machine learning, continuous and quantitative output values refer to the type of data that the model aims to predict or estimate.", "code": false},
                {"line": "'Continuous Output Values' are those that can take on any real number within a certain range. These values represent measurements that are not restricted to specific discrete points. For example, predicting the price of a house, the temperature, or the stock price are all examples of tasks where the output values are continuous.", "code": false},
                {"line": "'Quantitative Output Values' are similar to continuous values in that they are numeric and represent some quantity. However, they are typically more specific in nature and often represent counts or measurements of discrete objects or events. For example, predicting the number of items sold, the age of a person, or the number of defects in a manufacturing process are tasks where the output values are quantitative.", "code": false},
                {"line": "The main difference between continuous and quantitative output values lies in the nature of the data and the granularity of the predictions. Continuous output values can take on any value within a range, while quantitative output values are often counts or measurements of discrete entities or events.", "code": false},
                {"line": "However, the terms are often used interchangeably because quantitative data often involves continuous measurements.", "code": false},
                {"line": "Let's take a real life example:", "code": false},
                {"line": "Suppose we are predicting house prices based on various features like area, number of bedrooms and location. The predicted price would be a continuous output value because it can take any value within a certain range, such as $100,000 to $1,000,000. It is also a quantitative output value because it represents the amount of money, which is a quantity.", "code": false},
                {"line": "Continuous Output Value Examples:", "code": false},
                {"line": "Temperature readings can be measured with precision, such as 20.5°C or 68.3°F. The temperature can vary continuously, and there's no limit to the number of possible values.", "code": false},
                {"line": "Time is another continuous output value, where it can be measured down to fractions of a second. For example, 10:30:25.123 AM represents a precise time.", "code": false},
                {"line": "Quantitative Output Value Examples:", "code": false},
                {"line": "Number of Sales. In business, the number of sales made by a company within a certain period is a quantitative value. It represents the quantity of products of services sold.", "code": false},
                {"line": "The population of a city, country, or region is also quantitative. It represents the number of people living in that area and can be measured in millions or billions.", "code": false},
                {"line": "Inventory Levels. For a retail store, the quantity of items in inventory indicates how many units of each product are available for sale.", "code": false},
                {"line": "Test scores, such as scores on a math exam or a standardized test, represent a quantitative value of performance or proficiency level of individuals in a particular subject.", "code": false}
            ],
            "postTags": "",
            "id": 0.01
        },
        {
            "postTitle" : "Data Science Terminology - Regression Problem",
            "postLines" : [
                {"line": "Regression is a type of predictive modeling technique used in statistical learning, particularly in supervised machine learning. It's used when the target varialble, or the variable we want to predict, is continuous. In other words, regression helps us understand the relationship between one or more independent variables (also called predictors or features) and a continuous outcome variable.", "code": false },
                {"line": "The goal of regression analysis is to find the best-fitting mathematical model that describes the relationship between the independent variables and the dependent variable. This model can then be used to make predictions about the dependent variable for new data points where the independent variables are known.", "code": false},
                {"line": "For example, let's say we want to predict house prices based on factors like square footage, number of bedrooms, and location. In this case, square footage, number of bedrooms, and location would be our independent variables, and house price would be our dependent variable. We could use regression analysis to build a model that quantifies how each of these independent variables influences the house price, allowing us to make predicions about the price of a house based on its features.", "code": false},
                {"line": "There are different types of regression techniques, including linear regression, polynomial regression, and logistic regression, each suited for different types of data and relationships between variables. Linear regression, for example, assumes a linear relationship between the independent and dependent variables, while logistic regression is used when the dependent variable is binary (e.g., yes/no, true/false).", "code": false},
                {"line": "Overall, regression analysis is a powerful tool for understanding and predicting continuous outcomes based on other variables, making it widely used in fields like economics, finance, healthcare, and more.", "code": false}
            ],
            "postTags": "",
            "id" : 0.02
        },
        {
            "postTitle": "Data Science Terminology - Clustering Problem",
            "postLines": [
                {"line": "Clustering is a type of unsepervised machine learning technique used to group similar data points together based on their features or characteristics. Unlike supervised learning, where the algorithm is trained on labeled data (data with known outcomes), unsupervised learning works with unlabled data, meaning there are no predefined categories or classes.", "code": false},
                {"line": "The goal of clustering is to discover inherent structures or patterns in the data without prior knowledge of what those patterns might be. The algorithm idenrigies groups of data points that are more similar to each other than to those in other groups. These groups are called clusters.", "code": false},
                {"line": "Clustering algorithms typically measure the similarity between data points using a distance metric, such as Euclidean distance or cosine similarity. Data points that are close to each other in feature space are considered similar and are likely to be grouped together in the same cluster.", "code": false},
                {"line": "There are various clustering algorithms, each with its own approach to identifying clusters:", "code":false},
                {"line": "One of the most popular clustering algorithms is 'K-means' which partitions the data into a predefined number of clusters (K) based on the mean value of the data points in each cluster. It iteratively assigns data points to the nearest cluster centroid and updates the centroids until convergence.", "code":false},
                {"line": "'Hierarchical clustering': This algorithm builds a hierarchy of clusters by recursively merging or splitting clusters based on their similarity. It can produce dedrogram representations that show the hierarchical relationships between clusters.", "code":false},
                {"line": "'DBSCAN' (Density-Based Spation Clustering of Applications with Noise):", "code":false},
                {"line": "'Agglomerative clustering' is similar to hierarchical clustering, agglomerative clustering starts with each data point as a separate cluster and iteratively merges the closest pairs of clusters until only one cluster remains or a stopping criterion is met.", "code":false},
                {"line": "Clustering has many applications across various domains, including customer segmentation, anomaly detection, image segmentation, and document clustering. It helps uncover hidden patterns in data and can provide valuable insights for decision-making and analysis.", "code":false}
            ],
            "postTags": "",
            "id": 0.03
        },
        {
            "postTitle": "Hierarchical Algorithms - Agglomerative Clustering",
            "postLines": [
                {"line": "Agglomerative clustering is a bottom-up hierarchical clustering algorithm. It starts with each data point as a separate cluster and then iteratively merges the closest pairs of clusters until only one cluster remains or a stopping criterion is met.", "code": false},
                {"line": "A a step-by-step explanation of how agglomerative clustering works:", "code": false},
                {"line": "", "code": true},
                {"line": "1. Initialization. ", "code": true},
                {"line": "      Start with each data point as a singleton cluster. Each data point is considered a cluster of its own.", "code": true},
                {"line": "2. Compute pairwise distances.", "code": true},
                {"line": "      Calculate the distance or similarity between all pairs of clusters. The distance between clusters can be computed using various metrics, such as Euclidean distance, Manhattan distance, or cosine similarity.", "code": true},
                {"line": "3. Merge closest clusters.", "code": true},
                {"line": "      Identify the two clusters that are closest to each other based on the distance metric. Merge these two clusters into a single cluster.", "code": true},
                {"line": "4. Update distance matrix.", "code": true},
                {"line": "      Update the distance to matrix to reflect the distances between the newly formed cluster and all other clusters. Depending on the linkage criteria chosen (e.g., single linkage, complete linkage, avarage linkage), the distance between clusters may be computed differently.", "code": true},
                {"line": "5. Repeat.", "code": true},
                {"line": "      Repeat stept 2-4 until only one cluster remains or a stopping criterion is met. This stopping criterion can be based on the number of desired clusters, a specified distance threshold, or other criteria.", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": false},
                {"line": "The process of merging clusters continues iteratively until the desired number of clusters is obtained or until clusters become too dissimilar to merge further.", "code": false},
                {"line": "One key aspect of agglomerative clustering is the choice of linkage criteria, which determines how the distance between clusters is computed. There are several common linkage criteria:", "code": false},
                {"line": "'Single linkage' - the distance between two clusters is defined as the minimum distance between any two points in the two clusters. It tends to produce elongated clusters.", "code": false},
                {"line": "'Complete linkage' - the distance between two clusters is defined as the maximum distance between any two points in the two clusters. It tends to produce compact, spherical clusters.", "code": false},
                {"line": "'Average linkage' - the distance between two clusters is defined as the average distance between all pairs of points in the two clusters. It provides a balance between single and complete linkage.", "code": false},
                {"line": "Agglomerative clustering is intuitive and easy to understand, making it a popular choice for hierarchical clustering tasks. It can produce dendrogram visualizations that illustrate the hierarchical relationships between clusters, which can be helpful for understanding the structure of the data.", "code": false},
                {"line": "Agglomerative clustering can be used in various real-world applications across different domains. Some of the use cases include:", "code": false},
                {"line": "Market Segmentation", "code": false},
                {"line": "In marketing, agglomerative clustering can be used to segment customers based on their purchasing behavior or demographic information. By identifying groups of customers with similar characteristics, businesses can tailor their makreting strategies to target each segment more effecrively.", "code": false},
                {"line": "Genomic Analysis", "code": false},
                {"line": "In bioinformatics, agglomerative clustering can be applied to analyze gene expression data or DNA sequences. By clustering genes or genomic regions with similar expression patterns or sequences, researchers can uncover insights into genetic regulation, disease mechanisms, or evolutionary relationships.", "code": false},
                {"line": "Image Segmentation", "code": false},
                {"line": "In computer vision, agglomerative clustering can be used for image segmentation tasks. By clustering pixels based on their color or intensity values, images can be partitioned into distinct regions or objects. This is useful for tasks such as object detection, image segmentation, or content-based image retrieval.", "code": false},
                {"line": "Anomaly Detection", "code": false},
                {"line": "Agglomerative clustering can also be used for anomaly detection in various domains, such as network security, fraud detection, or equipment maintenance. By clustering data points and identifying clusters with significantly different characteristics from the rest, anomalies or outliers can be detected.", "code": false},
                {"line": "Document Clustering", "code": false},
                {"line": "In natural language processing (NLP), agglomerative clustering can be used for document clustering or topic modeling. By clustering documents based on their similarity in terms of word usage or semantic content, documents can be organized into thematic groups or topics, enabling tasks such as document classification, summarization, or recommendation.", "code": false},
                {"line": "These are just a few examples of how agglomerative clustering can be applied in practice. Its flexibility and versatility make it a valuable tool for exploratory data analysis, pattern recognition, and knowledge discovery in various fields.", "code": false}



                
                
            ],
            "postTags": "",
            "id": 1.0
        },
        {
            "postTitle": "Pros and Cons of Tools & Libraries dedicated for Data Science",
            "postLines": [
                {"line": "Python is a #highLevel programming language widely used across a variety of industries. Looking at the ranking charts of languages most commonly used among data scientists, it holds a very strong first place, well above the others by over 10%. We are noting a decline here, though, by 2%. Whilst the second in line, Java, is having a better time with 0.8% incline of usage in the data science industry. Also 10% further away places itself JavaScript programming language perhaps due to the campatibility with online websites and platforms. Other programming languages that follow our adorable and very visual JavaScript are not so far behind. Only by a little over 1% is C#, by 1.5% C/C++, and the last one being PHP with only a bit under 3% lacking to stand on the podium.", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "Data processing and modeling.", "code": false},
                {"line": "There are at least 8 Py libraries fit to accomplish such tasks." , "code":false},
                {"line": "1. NumPy (for Numerical Python) is a perfect tool for scientific computing and performing basic and advanced operations with arrays." , "code":false},
                {"line": "The library offers many handy features for performing operations on n-arrays and matrices in Python. It makes it possible to deal with arrays that store values of the same data type and facilitates the execution of mathematical operations on the arrays (and their vectorization). In fact, vectorizing mathematical operations on the NumPy array type increases performance and speeds up execution time." , "code":false},
                {"line": "2. SciPy (for Scientifical Python). This useful library includes modules for linear algebra, integration, optimization, and statistics. Its core functionality was built on NumPy, so its arrays use that library. SciPy works great for all sorts of scientific programming projects (science, math, and engineering). It offers efficient numerical routines such as numerical optimization, integration and others in sub-modules. The extensive documentation makes working with this library really easy." , "code":false},
                {"line": "3. Pandas is a library created to help developers work intuitively with 'tagged' and 'relational' data. It is based on two main data structures: 'Serial' (one-dimensional, like a Python list) and 'Dataframe' (two-dimensional, like a multi-column array). Pandas allows converting data structures into DataFrame objects, handling missing data and adding/removing columns from DataFrame, imputing missing files and plotting data with histogram or boxplot. It is an indispensable tool for data manipulation and visualization." , "code":false},
                {"line": "4. Keras is an excellent library for building neural networks and modeling. It is very simple to use and offers developers a good degree of extensibility. The library takes advantage of other packages (Theano or TensorFlow) as terminals. Moreover, Microsoft has integrated CNTK (Microsoft Cognitive Toolkit) to serve as another backend. This is a great choice if you want to experiment quickly using compact systems - the minimalist approach to design is really great!" , "code":false},
                {"line": "5. Scikit-Learn. It is an industry standard for Python-based data science projects. Scikits is a group of SciPy packages that were created for specific functionality - for example, image processing. Scikit-learn uses SciPy mathematical operations to expose a concise interface to the most common machine learning algorithms." , "code":false},
                {"line": "Data scientists use it to handle standard machine learning and data mining tasks such as clustering, regression, and classification. Another advantage? It comes with great documentation and offers high performance." , "code":false},
                {"line": "6. PyTorch is a framework that is perfect for data scientists who want to easily perform Deep Learning tasks. The tool allows performing tensor calculations with GPU acceleration. It is also used for other tasks - for example, to create dynamic computational graphs and automatically calculate gradients. PyTorch is based on Torch, which is an open-source Deep Learning library, implemented in C, with a skin in Lua." , "code":false},
                {"line": "7. TensorFlow is a Python framework popular to use in Machine Learning and Deep Learning, which was developed at Google Brain. It is the best tool for tasks such as object identification, voice recognition and many more. It lets you work with artificial neural networks that need to handle multiple data sets. The library includes several layer helpers (tflearn, tfslim, skflow) which make it even more functional. TensorFlow is constantly updated with new versions, including fixing possible security vulnerabilities or improving the integration of TensorFlow and the GPU." , "code": false},
                {"line": "8. XGBoost - Use this library to implement Machine Learning algorithms in the Gradient Boosting framework. XGBoost is portable, flexible and efficient. It offers parallel tree boosting that helps teams solve many data science problems. Another benegit is that developers can run the same code on leading distributed environments such as Hadoop, SGE, and MPI. " , "code":false},
                {"line": "9. Theano" , "code":false},
                {"line": "Data Visualisation" , "code":false},
                {"line": "1. Matplotlib is a standard data science library that helps produce data visualizations such as two-dimensional charts and graphs (histograms, scatter plots, non-Cartesian coordinate plots). Matplotlib is one of those plot libraries that are really useful in data science projects - it provides an object-oriented API for integrating plots into applications." , "code":false},
                {"line": " It is thanks to this library that Python can compete with scientific tools like MatLab or Mathematica. However, developers have to write more code than usual when using this library to build advanced visualizations. It is worth noting that popular plotting libraries work seamlessly with Matplotlib." , "code":false},
                {"line": "2. Seaborn is based on the previously mentioned" , "code":false},
                {"line": "" , "code":false},
                {"line": "" , "code":false},
                {"line": "" , "code":false},
                {"line": "" , "code":false},
                {"line": "" , "code":false},
                {"line": "" , "code":false},
                {"line": "" , "code":false},
                {"line": "" , "code":false},
                {"line": "" , "code":false},
                {"line": "" , "code":false},
                {"line": "" , "code":false},
                {"line": "" , "code":false},
                {"line": "" , "code":false}
            ],
            "postTags": "",
            "id": 2.10
        },
        {
            "postTitle": "NumPy - Efficient and Fast Open Source Python Library for Performing Numerical Operations",
            "postLines": [
                {"line": "#import NumPy library", "code": true},
                {"line": "import numpy as np", "code": true},
                {"line": "", "code": true},
                {"line": "#create Numpy array", "code": true},
                {"line": "regular_array = np.array([1, 2, 3, 4])", "code": true},
                {"line": "#print the created array", "code": true},
                {"line": "print(regular_array)", "code": true},
                {"line": "#array of zeros (shape of it within parentheses)", "code": true},
                {"line": "zeros_array = np.zeros((3, 3))", "code": true},
                {"line": "print(zeros_array)", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[[0. 0. 0.]", "code": true},
                {"line": " [0. 0. 0.]", "code": true},
                {"line": " [0. 0. 0.]]", "code": true},
                {"line": "#array of ones", "code": true},
                {"line": "ones_array = np.ones((3, 3))", "code": true},
                {"line": "print(ones_array)", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[[1. 1. 1.]", "code": true},
                {"line": " [1. 1. 1.]", "code": true},
                {"line": " [1. 1. 1.]]", "code": true},
                {"line": "#empty array", "code": true},
                {"line": "empty_array = np.empty((2, 3))", "code": true},
                {"line": "print(empty_array)", "code": true},
                {"line": "[[0. 0. 0.]", "code": true},
                {"line": " [0. 0. 0.]", "code": true},
                {"line": " [0. 0. 0.]]", "code": true},
                {"line": "#arange method on array", "code": true},
                {"line": "array_arange = np.arange(12)", "code": true},
                {"line": "print(array_arange)", "code": true},
                {"line": "[0 1 2 3 4 5 6 7 8 9 10 11]", "code": true},
                {"line": "array_arrange.reshape(3, 4)", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[[0, 1, 2, 3],", "code": true},
                {"line": " [4, 5, 6, 7],", "code": true},
                {"line": " [8, 9, 10, 11]]", "code": true},
                {"line": "#linspace - equaly spaced data elements", "code": true},
                {"line": "linear_data = np.linspace(11, 20, 5)", "code": true},
                {"line": "#11 - first element", "code": true},
                {"line": "#20 - last element", "code": true},
                {"line": "#5 - number of equidistant elements", "code": true},
                {"line": "print(linear_data)", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[11. 13.25 15.5 17.75 20. ]", "code": true},
                {"line": "#One dimensional array", "code": true},
                {"line": "one_dimension = np.arrange(15)", "code": true},
                {"line": "print(one_dimension)", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14]", "code": true},
                {"line": "#Two dimensional array", "code": true},
                {"line": "two_dimensions = one_dimension.reshape(3, 5)", "code": true},
                {"line": "print(two_dimensions)", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[[0, 1, 2, 3, 4],", "code": true},
                {"line": " [5, 6, 7, 8, 9]", "code": true},
                {"line": " [10, 11, 12, 13, 14]", "code": true},
                {"line": "#Three dimensional array", "code": true},
                {"line": "three_dimensions = np.arrange(27).reshape(3, 3, 3)", "code": true},
                {"line": "print(three_dimensions)", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[[[ 0 1 2 ]", "code": true},
                {"line": "  [ 3 4 5 ]", "code": true},
                {"line": "  [ 6 7 8 ]]", "code": true},
                {"line": " [[ 9 10 11 ]", "code": true},
                {"line": "  [ 12 13 14 ]", "code": true},
                {"line": "  [ 15 16 17 ]]", "code": true},
                {"line": " [[ 18 19 20 ]", "code": true},
                {"line": "  [ 21 22 23 ]", "code": true},
                {"line": "  [ 24 25 26 ]]]", "code": true}
            ],
            "postTags": "",
            "id": 2.11
        },
        {
            "postTitle": "PyGym Exercise 2.1",
            "postLines": [
                {"line": "Write a program that asks the user for their name and year of birth, then calculates and prints their age.", "code": false},
                {"line": "Examplary execution:", "code": false},
                {"line": "Give your name:", "code": false},
                {"line": "Johnny", "code": false},
                {"line": "Enter year of birth:", "code": false},
                {"line": "1989", "code": false},
                {"line": "John, you are 30 years old.", "code": false}
            ],
            "postTags": "",
            "id": 2.1
        },
        {
            "postTitle": "PyGym Exercise 2.2",
            "postLines": [
                {"line": "Write a program that asks the user for their name and year of birth, then calculates and prints their age.", "code": false},
                {"line": "Examplary execution:", "code": false},
                {"line": "Give your name:", "code": false},
                {"line": "Johnny", "code": false},
                {"line": "Enter year of birth:", "code": false},
                {"line": "1989", "code": false},
                {"line": "John, you are 30 years old.", "code": false}
            ],
            "postTags": "",
            "id": 2.2
        }
    ],
    "physics" : [
        {
            "postTitle": "Rigid Body and Rotation - Two Rotating Discs",
            "postLines": [
                {"line": "Two thin discs are attached to a horizontal axis, making 300 revolutions per second, 20 cm apart. To determine the speed of the bullet, it was fired in such a way that it pierced both targets at the same distance from the axis of rotation. Find the avarage speed of the bullet between the targets if the penetration points of the targets are offset by 18°.", "code": false},
                {"line": "Despite the complicated description, when we think carefully and imagine the whole situation, the task is very simple. We have the distance traveled, we do not have time and we have to calculate the avarage speed, by definition:", "code": false},
                {"line": "S = v*t", "code": false, "math": true},
                {"line": "So we need the time. It can be derived from the movement of the disks:", "code": false},
                {"line": "omega = 2 * pi * f", "code": false, "math": true},
                {"line": "alfa = omega * t", "code": false, "math": true},
                {"line": "Having these two simple equations, we can very easily derive the time:", "code": false},
                {"line": "t = (alfa)/(2 * pi * f)", "code": false, "math": true},
                {"line": "#array of zeros (shape of it within parentheses)", "code": true},
                {"line": "zeros_array = np.zeros((3, 3))", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[[0. 0. 0.]", "code": true},
                {"line": " [0. 0. 0.]", "code": true},
                {"line": " [0. 0. 0.]]", "code": true},
                {"line": "#array of ones", "code": true},
                {"line": "ones_array = np.ones((3, 3))", "code": true},
                {"line": "print(ones_array)", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[[1. 1. 1.]", "code": true},
                {"line": " [1. 1. 1.]", "code": true},
                {"line": " [1. 1. 1.]]", "code": true},
                {"line": "#empty array", "code": true},
                {"line": "empty_array = np.empty((2, 3))", "code": true},
                {"line": "print(empty_array)", "code": true},
                {"line": "[[0. 0. 0.]", "code": true},
                {"line": " [0. 0. 0.]", "code": true},
                {"line": " [0. 0. 0.]]", "code": true},
                {"line": "#arange method on array", "code": true},
                {"line": "array_arange = np.arange(12)", "code": true},
                {"line": "print(array_arange)", "code": true},
                {"line": "[0 1 2 3 4 5 6 7 8 9 10 11]", "code": true},
                {"line": "array_arrange.reshape(3, 4)", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[[0, 1, 2, 3],", "code": true},
                {"line": " [4, 5, 6, 7],", "code": true},
                {"line": " [8, 9, 10, 11]]", "code": true},
                {"line": "#linspace - equaly spaced data elements", "code": true},
                {"line": "linear_data = np.linspace(11, 20, 5)", "code": true},
                {"line": "#11 - first element", "code": true},
                {"line": "#20 - last element", "code": true},
                {"line": "#5 - number of equidistant elements", "code": true},
                {"line": "print(linear_data)", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[11. 13.25 15.5 17.75 20. ]", "code": true},
                {"line": "#One dimensional array", "code": true},
                {"line": "one_dimension = np.arrange(15)", "code": true},
                {"line": "print(one_dimension)", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14]", "code": true},
                {"line": "#Two dimensional array", "code": true},
                {"line": "two_dimensions = one_dimension.reshape(3, 5)", "code": true},
                {"line": "print(two_dimensions)", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[[0, 1, 2, 3, 4],", "code": true},
                {"line": " [5, 6, 7, 8, 9]", "code": true},
                {"line": " [10, 11, 12, 13, 14]", "code": true},
                {"line": "#Three dimensional array", "code": true},
                {"line": "three_dimensions = np.arrange(27).reshape(3, 3, 3)", "code": true},
                {"line": "print(three_dimensions)", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[[[ 0 1 2 ]", "code": true},
                {"line": "  [ 3 4 5 ]", "code": true},
                {"line": "  [ 6 7 8 ]]", "code": true},
                {"line": " [[ 9 10 11 ]", "code": true},
                {"line": "  [ 12 13 14 ]", "code": true},
                {"line": "  [ 15 16 17 ]]", "code": true},
                {"line": " [[ 18 19 20 ]", "code": true},
                {"line": "  [ 21 22 23 ]", "code": true},
                {"line": "  [ 24 25 26 ]]]", "code": true}
            ],
            "postTags": "",
            "id": 2.0
        },
        {
            "postTitle": "PyGym Exercise 2.1",
            "postLines": [
                {"line": "Write a program that asks the user for their name and year of birth, then calculates and prints their age.", "code": false},
                {"line": "Examplary execution:", "code": false},
                {"line": "Give your name:", "code": false},
                {"line": "Johnny", "code": false},
                {"line": "Enter year of birth:", "code": false},
                {"line": "1989", "code": false},
                {"line": "John, you are 30 years old.", "code": false}
            ],
            "postTags": "",
            "id": 2.1
        },
        {
            "postTitle": "PyGym Exercise 2.2",
            "postLines": [
                {"line": "Write a program that asks the user for their name and year of birth, then calculates and prints their age.", "code": false},
                {"line": "Examplary execution:", "code": false},
                {"line": "Give your name:", "code": false},
                {"line": "Johnny", "code": false},
                {"line": "Enter year of birth:", "code": false},
                {"line": "1989", "code": false},
                {"line": "John, you are 30 years old.", "code": false}
            ],
            "postTags": "",
            "id": 2.2
        }
    ]   
  } 
 ]