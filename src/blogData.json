[
  {
    "general" : [
        {
            "postTitle": "The Intersection of Cognitive Sciences and Python",
            "postLines": [
                {"line": "Cognitive science is an interdisciplinary field that explores the nature of the human mind and its processes. It draws from various disciplines, including psychology, neuroscience, linguistics, philosophy, and computer science. The goal is to understand how people perceive, think, learn, and remember. As the field grows, the use of advanced computational tools, especially programming languages like Python, has become increasingly important.", "code": false, "subtitle": false},
                {"line": "Python: A Versatile Tool for Cognitive Scientists", "code": false, "subtitle": true},
                {"line": "Python is a high-level programming language known for its simplicity, readability, and vast ecosystem of libraries. It has become a go-to tool for researchers and practitioners in congnitive science due to its versatility and ease of use. Here's how Python can be useful in various aspects of cognitive science:", "code": false, "subtitle": false},
                {"line": "1. Data Analysis and Visualisation", "code": false, "subtitle": true},
                {"line": "Python offers poweful libraries such as Pandas, NumPy, and Matplotlib that facilitate data manipulation and visualization. Researchers can use these tools to analyze experimental data, visualize patterns, and draw meaningful conclusions. For example, Pandas enables efficient data handling, while Matplotlib and Seaborn are ideal for creating informative graphs and plots.", "code":false, "subtitle": false},
                {"line": "In cognitive research, these tools are instrumental in several ways:", "code": false, "subtitle": false},
                {"line": "1. Data Collection and Cleaning: Cognitive researchers often collect large datasetsthrough experiments, surveys, and neuroimaging techniques. Pandas, a data manipulation library, provides functionalities to import, clean, and preprocess this data efficiently. This step is crucial to ensure the accuracy and reliability of the subsequent analysis. For instance, researchers can handle missing data, filter outliers, and standardize data formats using Pandas.", "code": false, "subtitle": false},
                {"line": "2. Statistical Analysis: NumPy, a library for numerical computing, is used for performing statistical analyses on experimental data. Researchers can calculate descriptive statistics such mean, median, standard deviation, and perform inferential statistics like t-tests, ANOVA, and regression analyses. These statistical methods help in understanding the underlying patterns and relationships in the data, which are essential for testing hypotheses in cognitive research.", "code": false, "subtitle": false},
                {"line": "3. Visualization of Results: Visualization is key to making sense of complex data. Matplotlib and Seaborn are powerful visualization libraries that allow researchers to create a variety of plots and graphs, such as histograms, scatter plots, and heatmaps. These visualization help in identifying trends, outliers, and correlations within the data. For example, a researcher studying reaction times across different conditions might use a box plot to visualize the distribution of reaction times and highlight any significant differences.", "code": false, "subtitle": false},
                {"line": "4. Time-Series Analysis: Cognitive research often involves analyzing time-series data, such as EEG recording or reaction time sequences. Pandas and Matplotlib provide functionalities for time-series analysis allowing researchers to visualize and analyze changes over time. For instance, a researcher might use these tools to plot EEG signals over time and identify patterns associated with specific cognitive tasks.", "code": false, "subtitle": false},
                {"line": "5. Neuroimaging Data: In studies involving neuroimaging data, such as fMRI or PET scans, visualtizations play a crucial role in interpreting brain activity. Libraries like Nilearn (built on top of NumPy and Matplotlib) offer specialized tools for visualizing brain maps and connectomes. Researchers can create 3D plots of brain activity, overlay statistical maps, and visualize functional connectivity between brain regions.", "code": false, "subtitle": false},
                {"line": "6. Machine Learning and Predictive Modeling: Python's integration with machine learning libraries like Scikit-learn allows researchers to build predictive models based on cognitive data. Visualization tools are used to interpret model outputs, such as feature importance and classification boundaries. This approach is particularly useful in identifying cognitive markers for conditions like Alzheimer's disease or ADHD.", "code": false, "subtitle": false},
                {"line": "Example in Practice", "code": false, "subtitle": true},
                {"line": "Imagine a study investigating the impact of sleep deprivation on cognitive performance. Researchers collect data on participants' reaction times and accuracy in various cognitive tasks. Using Pandas, they preprocess the data by handling missing values and normalizing the scores. With NumPy, they perform statistical tests to compare reaction times between well-rested and sleep-deprived groups.", "code": false, "subtitle": false},
                {"line": "To visualize the results, they yse Seaborn to create box plots showing the distribution of reaction times and bar graphs to illustrate differences in accuracy. Additionally, they employ time-series analysis to visualize changes in performance over multiple testing sessions. These visualizations help in drawing meaningful conclusions about the effects of sleep deprivation on cognitive functions.", "code": false, "subtitle": false},
                {"line": ""}               
            ]
        },
        {
            "postTitle": "How Programming Supports Learning Mathematics and Physics?",
            "postLines": [
                {"line": "Mathematics and physics are disciplines deeply rooted in calculations and modeling. Over the yars, programming has revolutionized the way we approach problems in these fields, making processes more efficient and accurate. In this article, you'll discover:", "code": false, "subtitle": false},
                {"line": "\u26AC The best programming languages for mathematics", "code": false},
                {"line": "\u26AC How algorithms transform scientific computations.", "code": false},
                {"line": "\u26AC Examples of tools and programs that simplify learning in these areas.", "code": false},
                {"line": "Why programming Matters in Mathematics and Physics", "code": false, "subtitle": true},
                {"line": "Programming bridges the gap between theoretical concepts and practical applications, empowering mathematicians and physicists to tackle problems with unprecedented efficiency. It enables the creation of interactive simulations that bring abstract theories to life, providing insights that would be difficult or impossible to achieve through manual calculations.", "code": false},
                {"line": "In physics, as an example, simulations of planetary motion allow us to predict celestial mechanics with pinpoint accuracy, while programming tools like finite element analysis help engineers model stress and strain in materials. In mathematics, programming facilitates solving non-linear equations, generating visual representations of complex surfaces, or even exploring higher-dimensional geometry.", "code": false},
                {"line": "Beyond problem-solving, programming enhances how students and professionals visualize data and models, offering an intuitive way to grasp difficult concepts. Tools like 3D graphing software and animations allow users to explore everything from the flow of electric fields to the shapes of polynomial functions, making abstract ideas tangible and exciting.", "code": false},
                {"line": "As science grows more data-driven, programming has become indispensable in analyzing vast datasets, automating repetitive tasks, and uncovering patterns that deepen our understanding of the mathematical and physical worlds.", "code": false},
                {"line": "Best Programming Languages for Mathematics and Physics", "code": false, "subtitle": true},
                {"line": "1. Python", "code": false, "subsubtitle": true},
                {"line": "Python is one of the most popular programming languages for mathematical and physical computations. Its extensive libraries, such as:", "code": false},
                {"line": "\u26AC NumPy (for numerical computing),", "code": false},
                {"line": "\u26AC SciPy (for scientific computations), and", "code": false},
                {"line": "\u26AC SymPy (for symbolic mathematics),", "code": false},
                {"line": "make it a versatile tool for solving equations, modeling systems, and performing data analysis.", "code": false},
                {"line": "2. MATLAB", "code": false, "subsubtitle": true},
                {"line": "A favorite among engineers and scientists, MATLAB excels in advanced calculations, matrix operations, and creating simulations. Its built-in functions and ease of use make it ideal for solving equations and visualizing data in physics and mathematics.", "code": false},
                {"line": "3. C++", "code": false, "subsubtitle": true},
                {"line": "Known for its high performance, C++ is often used in physics for simulation-heavy tasks, such as modeling particle systems or simulating physical phenomena in real-time. Its efficiency makes it suitable for large-scale projects that demand precision.", "code": false},
                {"line": "4. R", "code": false, "subsubtitle": true},
                {"line": "While primarily used for statistics, R is also applicable in mathematical modeling and data visualization, especially when dealing with complex datasets.", "code": false},
                {"line": "5. Julia", "code": false, "subsubtitle": true},
                {"line": "A relatively new language, Julia is designed for high-performance numerical and scientific computing. It combines the speed of C++ with the simplicity of Python, making it a rising star in academia.", "code": false},
                {"line": "How Algorithms Transform Scientific Computations", "code": false, "subtitle": true},
                {"line": "Algorithms form the foundation of problem-solving in mathematics and physics. From Newton’s method for solving equations to Monte Carlo simulations for modeling random systems, programming enables precise and scalable computation.", "code": false},
                {"line": "Key Applications:", "code": false, "subsubtitle": true},
                {"line": "\u26AC Simulating Physical Phenomena - Algorithms allow scientists to model real-world systems, such as the movement of celestial bodies or fluid dynamics.", "code": false},
                {"line": "\u26AC Optimizing Mathematical Models - By iteratively testing variables, algorithms find the best solutions to equations or models.", "code": false},
                {"line": "\u26AC ", "code": false}
            ],
            "postTags": "",
            "id": 0.1
        },
        {
            "postTitle": "Bitcoin: A Peer-to-Peer Electronic Cash System",
            "postLines": [
                {"line": "Satoshi Nakamoto", "code": false},
                {"line": "satoshin@gmx.com", "code": false},
                {"line": "www.bitcoin.org", "code": false},
                {"line": "Abstract. A purely peer-to-peer version of electronic cash would allow online payments to be sent directly from one party to another without going through a financial institution. Digital signatures provide part of the solution, but the main benefits are lost if a trusted third party is still required to prevent double-spending. We propose a solution to the double-spending problem using a peer-to-peer network. The network timestamps transactions by hashing them into an ongoing chain of hash-based proof-of-work, forming a record that cannot be changed without redoing the proof-of-work. The longest chain not only serves as proof of the sequence of events witnessed, but proof that it came from the largest pool of CPU power. As long as a mojority of CPU power is controlled by nodes that are not cooperating to attack the network, they'll generate the longest chain and outpace attackers. The network itself requires minimal structure. Messages are broadcast on a best effort basis, and nodes can leave and rejoin the network at will, accepting the longest proof-of-work chain as proof of what happened while they were gone.", "code": false},
                {"line": "1. Introduction", "code": false},
                {"line": "Commerce on the Internet has come to rely almost exclusively on financial institutions serving as trusted third parties to process electronic payments. While the system works well enough for most transactions, it still suffers from the inherent weaknesses of the trust based model. Completely non-reversible transactions are not really possible, since financial institutions cannot avoid mediating disputes. The cost of mediation increases transaction costs, limiting the minimum practical transaction size and cutting off the possibility for small casual transactions, and there is a broader cost in the loss of ability to make non-reversible payments for non reversible services. With the possibility of reversal, the need for trust spreads. Merchants must be wary of their customers, hassling them for more information than they would otherwise need. A certain percentage of fraud is accepted as unavoidable. These costs and payment uncertainties can be avoided in person by using physical currency, but no mechanism exists to make payments over a communications channel without a trusted party.", "code": false},
                {"line": "What is needed is an electronic payment system based on cryptographic proof instead of trust, allowing any two willing parties to transact directly with each other without the need for a trusted third party. Transactions that are computationally impractical to reverse would protect sellers from fraud, and routine escrow mechanisms could easily be implemented to protect buyers. In this paper, we propose a solution to the double-spending problem using a peer-to-peer distributed timestamp server to generate computational proof of the chronological order of transaction. The system is secure as long as honest nodes collectively control more CPU power than any cooperationg group of attacker nodes.", "code": false},
                {"line": "2. Transactions", "code": false},
                {"line": "We define an electronic coin as a chain of digital signatures. Each owner transfers the coin to the next by digitally signing a hash of the previous transaction and the public key of the next owner and adding these to the end of the coin. A payee can verify the signatures to verify the chain of ownership.", "code": false},
                {"line": "The problem of course is the payee can't verify that one of the owners did not double-spend the coin. A common solution is to introduce a trusted central authority, or mint, that checks every transaction for double spending. After each transaction, the coin must be returned to the mint to issue a new coin, and only coins issued directly from the mint are trusted not to be double-spent. The problem with this solution is that the fate of the entire money system depends on the company running the mint, with every transaction having to go through them, just like a bank.", "code": false},
                {"line": "We need a way for the payee to know that the previous owners did not sign any earlier transactions. For our purposes, the earliest transaction is the one that counts, so we don't care about later attempts to double-spend. The only way to confirm the abscence of a transaction is to be aware of all transactions. In the mint based model, the mint was aware of all transactions and decided which arrived first. To accomplish this without a trusted party, transactions must be publicly announced [1], and we need a system for participants to agree on a single history of the order in which they were received. The payee needs proof that at the time of each transaction, the majority of nodes agreed it was the first received.", "code": false},
                {"line": "3. Timestamp Server", "code": false},
                {"line": "The solution we propse begins with a timestamp server. A timestamp server works by taking a hash of block of items to be timestamped and widely publishing the hash, such as in a newspaper or Usenet post [2-5]. The timestamp proves that the data must have existed at the time, obviously, in order to get into the hash. Each timestamp includes the previous timestamp in its hash, forming a chain, with each additional timestamp reinforcing the ones before it.", "code": false},
                {"line": "4. Proof-of-Work", "code": false},
                {"line": "To implement a distributed timestamp server on a peer-to-peer basis, we will need to use a proof-of-work system similar to Adam Back's Hashcash [6], rather than newspaper or Usenet posts. The proof-of work involves scanning for a value that when hashed, such as with SHA-256, the hash begins with a number of zero bits. The avarage work required is exponential in the number of zero bits required and can be verified by executing a single hash.", "code": false},
                {"line": "For our timestamp network, we implement the proof-of-work by incrementing a nonce in the block until a value is found that gives the block's hash the required zero bits. Once the CPU effort has been expended to make it satisfy the proof-of-work, the block cannot be changed without redoing the work. As later blocks are chained after it, the work to change the block would include redoing all the block after it.", "code": false},
                {"line": "The proof-of-work also solves the problem of determining representation in majority decision making. If the majority were based on one-IP-address-one-vote, it could be subverted by anyone able to allocate many IPs. Proof-of-work is essentially one-CPU-one-vote. The majority decision is represented by the longest chain, which has the greatest proof-of-work effort invested in it. If a majority of CPU power is controlled by honest nodes, the honest chain will grow the fastest and outpace any competing chains. To modify a past block, an attacker would have to redo the proof-of-work of the block and all blocks after it and then catch up with and surpass the work of the honest nodes. We will show later that the probability of a slower attacker catching up diminishes exponentially as subsequent blocks are added.", "code": false},
                {"line": "To compensate for increasing hardware speed and varying interest in running nodes over time, the proof-of-work difficulty is determined by a moving average targeting an average number of blocks per hour. If they're generated too fast, the difficulty increases.", "code": false},
                {"line": "5. Network", "code": false},
                {"line": "The steps to run the network are as follows:", "code": false},
                {"line": "1) New transactions are broadcast to all nodes.", "code": false},
                {"line": "2) Each node collects new transactions into a block.", "code": false},
                {"line": "3) Each node works on finding a difficult proof-of-work for its block.", "code": false},
                {"line": "4) When a node finds a proof-of-work, it broadcasts the block to all nodes.", "code": false},
                {"line": "5) Nodes accept the block only if all transactions in it are valid and not already spent.", "code": false},
                {"line": "6) Nodes express their acceptance of the block by working on creating the next block in the chain, using the hash of the accepted block as the previous hash.", "code": false},
                {"line": "Nodes always consider the longest chain to be the correct one and will keep working on extending it. If two nodes broadcast different versions of the next block simultaneously, some nodes may receive one or the other first. In that case, they work on the first one they received, but save the other branch in case it becomes longer. The tie will be broken when the next proofof-work is found and one branch becomes longer; the nodes that were working on the other branch will then switch to the longer one.", "code": false},
                {"line": "New transaction broadcasts do not necessarily need to reach all nodes. As long as they reach many nodes, they will get into a block before long. Block broadcasts are also tolerant of dropped messages. If a node does not receive a block, it will request it when it receives the next block and realizes it missed one", "code": false},
                {"line": "6. Incentive", "code": false},
                {"line": "By convention, the first transaction in a block is a special transaction that starts a new coin owned by the creator of the block. This adds an incentive for nodes to support the network, and provides a way to initially distribute coins into circulation, since there is no central authority to issue them. The steady addition of a constant of amount of new coins is analogous to gold miners expending resources to add gold to circulation. In our case, it is CPU time and electricity that is expended.", "code": false},
                {"line": "The incentive can also be funded with transaction fees. If the output value of a transaction is less than its input value, the difference is a transaction fee that is added to the incentive value of the block containing the transaction. Once a predetermined number of coins have entered circulation, the incentive can transition entirely to transaction fees and be completely inflation free.", "code": false},
                {"line": "The incentive may help encourage nodes to stay honest. If a greedy attacker is able to assemble more CPU power than all the honest nodes, he would have to choose between using it to defraud people by stealing back his payments, or using it to generate new coins. He ought to find it more profitable to play by the rules, such rules that favour him with more new coins than everyone else combined, than to undermine the system and the validity of his own wealth.", "code": false},
                {"line": "7. Reclaiming Disk Space", "code": false},
                {"line": "Once the latest transaction in a coin is buried under enough blocks, the spent transactions before it can be discarded to save disk space. To facilitate this without breaking the block's hash, transactions are hashed in a Merkle Tree [7][2][5], with only the root included in the block's hash. Old blocks can then be compacted by stubbing off branches of the tree. The interior hashes donot need to be stored.", "code": false},
                {"line": "A block header with no transactions would be about 80 bytes. If we suppose blocks are generated every 10 minutes, 80 bytes * 6 * 24 * 365 = 4.2MB per year. With computer systems typically selling with 2GB of RAM as of 2008, and Moore's Law predicting current growth of 1.2GB per year, storage should not be a problem even if the block headers must be kept in memory.", "code": false},
                {"line": "8. Simplified Payment Verification", "code": false},
                {"line": "It is possible to verify payments without running a full network node. A user only needs to keep a copy of the block headers of the longest proof-of-work chain, which he can get by querying network nodes until he's convinced he has the longest chain, and obtain the Merkle branch linking the transaction to the block it's timestamped in. He can't check the transaction for himself, but by linking it to a place in the chain, he can see that a network node has accepted it, and blocks added after it further confirm the network has accepted it.", "code": false},
                {"line": "As such, the verification is reliable as long as honest nodes control the network, but is more vulnerable if the network is overpowered by an attacker. While network nodes can verify transactions for themselves, the simplified method can be fooled by an attacker's fabricated transactions for as long as the attacker can continue to overpower the network. One strategy to protect against this would be to accept alerts from network nodes when they detect an invalid block, prompting the user's software to download the full block and alerted transactions to confirm the inconsistency. Businesses that receive frequent payments will probably still want to run their own nodes for more independent security and quicker verification", "code": false},
                {"line": "9. Combining and Splitting Value", "code": false},
                {"line": "Although it would be possible to handle coins individually, it would be unwieldy to make a separate transaction for every cent in a transfer. To allow value to be split and combined, transactions contain multiple inputs and outputs. Normally there will be either a single input from a larger previous transaction or multiple inputs combining smaller amounts, and at most two outputs: one for the payment, and one returning the change, if any, back to the sender. ", "code": false},
                {"line": "It should be noted that fan-out, where a transaction depends on several transactions, and those transactions depend on many more, is not a problem here. There is never the need to extract a complete standalone copy of a transaction's history", "code": false},
                {"line": "10. Privacy", "code": false},
                {"line": "The traditional banking model achieves a level of privacy by limiting access to information to the parties involved and the trusted third party. The necessity to announce all transactions publicly precludes this method, but privacy can still be maintained by breaking the flow of information in another place: by keeping public keys anonymous. The public can see that someone is sending an amount to someone else, but without information linking the transaction to anyone. This is similar to the level of information released by stock exchanges, where the time and size of individual trades, the \"tape\", is made public, but without telling who the parties were", "code": false},
                {"line": "As an additional firewall, a new key pair should be used for each transaction to keep them from being linked to a common owner. Some linking is still unavoidable with multi-input transactions, which necessarily reveal that their inputs were owned by the same owner. The risk is that if the owner of a key is revealed, linking could reveal other transactions that belonged to the same owner.", "code": false},
                {"line": "11. Calculations", "code": false},
                {"line": "We consider the scenario of an attacker trying to generate an alternate chain faster than the honest chain. Even if this is accomplished, it does not throw the system open to arbitrary changes, such as creating value out of thin air or taking money that never belonged to the attacker. Nodes are not going to accept an invalid transaction as payment, and honest nodes will never accept a block containing them. An attacker can only try to change one of his own transactions to take back money he recently spent.", "code": false},
                {"line": "The race between the honest chain and an attacker chain can be characterized as a Binomial Random Walk. The success event is the honest chain being extended by one block, increasing its lead by +1, and the failure event is the attacker's chain being extended by one block, reducing the gap by -1.", "code": false},
                {"line": "The probability of an attacker catching up from a given deficit is analogous to a Gambler's Ruin problem. Suppose a gambler with unlimited credit starts at a deficit and plays potentially an infinite number of trials to try to reach breakeven. We can calculate the probability he ever reaches breakeven, or that an attacker ever catches up with the honest chain, as follows [8]:", "code": false},
                {"line": "p = probability an honest node finds the next block", "code": false},
                {"line": "q = probability the attacker finds the next block", "code": false},
                {"line": "qz = probability the attacker will ever catch up from z blocks behind", "code": false},
                {"line": "equasion", "code": false, "math": true, "inline": false},
                {"line": "Given our assumption that p > q, the probability drops exponentially as the number of blocks the attacker has to catch up with increases. With the odds against him, if he doesn't make a lucky lunge forward early on, his chances become vanishingly small as he falls further behind.", "code": false},
                {"line": "We now consider how long the recipient of a new transaction needs to wait before being sufficiently certain the sender can't change the transaction. We assume the sender is an attacker who wants to make the recipient believe he paid him for a while, then switch it to pay back to himself after some time has passed. The receiver will be alerted when that happens, but the sender hopes it will be too late.", "code": false},
                {"line": "The receiver generates a new key pair and gives the public key to the sender shortly before signing. This prevents the sender from preparing a chain of blocks ahead of time by working on it continuously until he is lucky enough to get far enough ahead, then executing the transaction at that moment. Once the transaction is sent, the dishonest sender starts working in secret on a parallel chain containing an alternate version of his transaction.", "code": false},
                {"line": "The recipient waits until the transaction has been added to a block and z blocks have been linked after it. He doesn't know the exact amount of progress the attacker has made, but assuming the honest blocks took the average expected time per block, the attacker's potential progress will be a Poisson distribution with expected value:", "code": false},
                {"line": "=z q p", "code": false, "math": true, "inline": false},
                {"line": "To get the probability the attacker could still catch up now, we multiply the Poisson density for each amount of progress he could have made by the probability he could catch up from that point:", "code": false},
                {"line": "∑", "code": false, "math": true, "inline": false},
                {"line": "Rearranging to avoid summing the infinite tail of the distribution...", "code": false},
                {"line": "∑", "code": false},
                {"line": "Converting to C code...", "code": false},
                {"line": "#include <math.h>", "code": true},
                {"line": "double AttackerSuccessProbability(double q, int z)", "code": true},
                {"line": "{", "code": true},
                {"line": "    double p = 1.0 - q;", "code": true},
                {"line": "    double lambda = z * (q / p);", "code": true},
                {"line": "    double sum = 1.0;", "code": true},
                {"line": "    int i, k;", "code": true},
                {"line": "    for (k = 0; k <= z; k++)", "code": true},
                {"line": "    {", "code": true},
                {"line": "       double poisson = exp(-lanbda);", "code": true},
                {"line": "       for (i = 1; i <= k; i++)", "code": true},
                {"line": "          poisson *= lambda / i; ", "code": true},
                {"line": "       sum -= poisson * (1 - pow(q / p, z - k));", "code": true},
                {"line": "    }", "code": true},
                {"line": "    return sum;", "code": true},
                {"line": "}", "code": true},
                {"line": "Running some results, we can see the probability drop off exponentially with z.", "code": false},
                {"line": "q=0/1", "code": true},
                {"line": "z=0    P=1.0000000", "code": true},
                {"line": "z=1    P=0.2045873", "code": true},
                {"line": "z=2    P=0.0509779", "code": true},
                {"line": "z=3    P=0.0131722", "code": true},
                {"line": "z=4    P=0.0034552", "code": true},
                {"line": "z=5    P=0.0009137", "code": true},
                {"line": "z=6    P=0.0002428", "code": true},
                {"line": "z=7    P=0.0000647", "code": true},
                {"line": "z=8    P=0.0000173", "code": true},
                {"line": "z=9    P=0.0000046", "code": true},
                {"line": "z=10   P=0.0000012", "code": true},
                {"line": "q=0.3", "code": true},
                {"line": "z=0    P=1.0000000", "code": true},
                {"line": "z=5    P=0.1773523", "code": true},
                {"line": "z=10    P=0.0416605", "code": true},
                {"line": "z=15    P=0.0101008", "code": true},
                {"line": "z=20    P=0.0024804", "code": true},
                {"line": "z=25    P=0.0006132", "code": true},
                {"line": "z=30    P=0.0001522", "code": true},
                {"line": "z=35    P=0.0000379", "code": true},
                {"line": "z=40    P=0.0000095", "code": true},
                {"line": "z=45    P=0.0000024", "code": true},
                {"line": "z=50    P=0.0000006", "code": true},
                {"line": "Solving for P less than 0.1%...", "code": false},
                {"line": "P < 0.001", "code": true},
                {"line": "q=0.10    z=5", "code": true},
                {"line": "q=0.15    z=8", "code": true},
                {"line": "q=0.20    z=11", "code": true},
                {"line": "q=0.25    z=15", "code": true},
                {"line": "q=0.30    z=24", "code": true},
                {"line": "q=0.35    z=41", "code": true},
                {"line": "q=0.40    z=89", "code": true},
                {"line": "q=0.45    z=340", "code": true},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false}
            ],
            "postTags": "",
            "id": 1
        },
        {
            "postTitle": "How do cryptocurrencies work? What is blockchain technology?",
            "postLines": [
                {"line": "Cryptocurrencies - what is it?", "code": false},
                {"line": "Many people will be tempted to call cryptocurrencies digital money. Most of all, due to the fact that they can perform a payment function. However, the truth is that it is not a currency in the strict sense. Completely different mechanisms are at work here. It is definitely better to consider cryptocurrencies as a form of investing money. Especially since most of the buying and selling takes place on the stock market. Many people decide to buy cryptocurrencies in exchange offices for cryptocurrencies, which provide the service of buying and selling digital currencies, including the most popular bitcoin. Cryptocurrencies exist only in virtual form. Their price, as it happens on the stock exchange, is the result of free market mechanisms, determined by the current demand and supply.", "code": false},
                {"line": "how cryptocurrencies were created?", "code": false},
                {"line": "Probably the explanation that cryptocurrencies are virtual funds in which you can invest is not enough to understand what they are and what their principle of operation is. So it's worth going back to the moment of their creation. In 2008, Satoshi Nakamoto (programmer or group of developers) published his manifesto, which was the inauguration of bitcoin. It was titled: \"Bitcoin: A peer-to-peer electronic money system.\" It was from the manifest that it was possible to find out how cryptocurrency works, so an explanation of blockchain technology was included. What is this? How does it matter?", "code": false},
                {"line": "Blockchain technology - how to understand it?", "code": false},
                {"line": "In principle, most cryptocurrencies use the same technology. So they function in a similar way. The entire mechanics of their operation is based on a decentralized system. It is the one of the main ideas of blockchain technology. Blockchain, literally translated, means \"a chain of blocks\" and it is a perfect pictorial representation of the issue.", "code": false},
                {"line": "How should blockchain be understood?", "code": false},
                {"line": "It is a technology that allows data to be stored using a cryptographic chain. Because this information is retrieved, verified, and encrypted using complex mathematical calculations, it is secure. Moreover, it is impossible to counterfeit both cryptocurrencies and the operations they participate in. It is worth knowing that in blockchain technology, information is not stored in one database, but is dispersed among many network users. Often the calculations (in the case of proof-of-work) also take place on their computers, using their computing power. Of course they get paid for it.", "code": false},
                {"line": "However, this should not be understood as intermediary process. Blockchain technology works directly between the sending and receiving parties. However, that's not all there is to know. In blockchain technology, the parties to the transaction only have the necessary details about them, although both the accounting register and the basic data for the operation are publicly available. Blockchain is a public record for everyone. This is the data that is placed in the blocks.", "code": false},
                {"line": "Each subsequent one is built on the basis of the previous one and contains information linking it to the next one. In this way, they create the aforementioned \"blockchain\". Thus, in the case of a blockchain, once entered data cannot be deleted or modified", "code": false},
                {"line": "It is worth knowing that this technology can also be used for other purposes, just like digital currencies can be implemented without a blockchain. The truth is, however, that it offers amazing technical benefits. This is why today the world's cryptocurrencies that are traded are based on blockchains.", "code": false}
            ],
            "postTags": "Blockchain, Crypto, Cryptocurrencies, Bitcoin, Satoshi Nakamoto",
            "id": 2
        },
        {
            "postTitle": "Will the act on artificial intelligence protect us from the invasion of robots and the annihilation of humanity?",
            "postLines": [
                {"line": "\"In April 2021, the European Commission presented a very important legislative project - the Artificial Intelligence (AIA) Act, which is intended to establish a strong framework for human protection in the era of artificial intelligence. It also has other goals, such as promoting innovation through the so-called regulatory sandboxes or facilitations for entities from the SME sector, but the foundation is indeed a human being and fundamental rights and values. AIA has undergone a major evolution over the last two years, all due to unclear or too general terms and sometimes unrealistic assumptions that would prevent the implementation of appropriate solutions by the addressees of specific requirements.", "code": false},
                {"line": "In the meantime, other acts have appeared, such as the European Data Governance Act, the Data Act and the Digital Single Market Regulation. (...) it is worth knowing that the legal framework in this area is subject to very dynamic changes. Each of these legal acts - in its own way - is to protect us against the risks that artificial intelligence may generate.", "code": false},
                {"line": "Well, is this really about artificial intelligence? AIA itself uses the term not so much artificial intelligence as artificial intelligence systems, which – in simple terms – we treat as software or a system, a protocol or a set of instructions, developed by a man and in order to perform a task defined by him, although with the use of techniques and approaches that can be evidence of (seeming) autonomy, i.e. machine learning or deep learning. These systems have been classified according to the level of risk generated, and such classification is to be associated with specific obligations on the part of individual 'actors' of the life cycle of such a system.", "code": false},
                {"line": "The classification is relatively simple, although in each of the subsequent iterations there are certain 'flavors' aimed at specifying the expectations of the EU legislator. So, as originally proposed, we have artificial intelligence systems that will be banned; high-risk systems (quite wide catalogue); systems with an increased level of transparency and others. One of the latest proposals assumes the introduction of the concept of general-purpose systems, e.g. ChatGPT, Google Translate or systems for creating 'deep fakes', which will probably constitute the fifth category, however, similar to high-risk systems.", "code": false},
                {"line": "If we take a closer look at this classification, we will see that the prohibited practices include systems used by the public sector for the so-called social scoring or identification of citizens in public space (with exceptions) and those used by the private sector, such as systems that manipulate people, e.g. using their weaknesses or subliminal techniques. In turn, the high-risk ones are associated with the risk of violating the fundamental rights contained in the Charter of Fundamental Rights and we will find there, among others: systems for assessing job candidates, biometric identification systems or some solutions in the field of judiciary and prevention. These systems will entail specific – quite significant – obligations, the failure to comply with which will entail the risk of imposing an administrative sanction, which is to be quite - financially - severe.", "code": false},
                {"line": "And finally, the third category, which is to be related to the need to inform a person about the interaction not with another person, but with an 'automaton'. Chatbots, videobots or voice assistants, this is what the AIA draws attention to in the context of transparency.", "code": false},
                {"line": "At this point, let's return to the title question - will the act on artificial intelligence protect us from the invasion of robots and the destruction of humanity? That's not what the AIA is about. Rather, the aim is to impose some high standards on developers, operators and users of systems, who will have to pay more attention to what they design, deliver and use. Assuming that in the foreseeable future we will not be able to create an autonomous and, above all, conscious artificial intelligence system, we must protect ourselves from others. Unfortunately.", "code": false},
                {"line": "AIA imposes strict requirements and restrictions, which, however, are aimed at ensuring supervision, risk management, such as algorithmic bias (bias), high-quality data or the use of innovative solutions as intended and for the benefit of man. Regulations alone will not eliminate the risks associated with the improper or ethical use of such systems. Harm (economic, physical or psychological) and damages will also accompany us in the context of AI systems. The Union is working intensively to define clear rules in this area as well. One way or another, it will still be something for which man will be responsible. After all, today no one seriously thinks about granting legal personality to 'robots'. It is man who stands behind the system and it depends only on him whether it will serve humanity or become another obstacle for it, or even a 'small' destruction.\"", "code": false}
            ],
            "postTags": "AI, Artificial, Inteligence, Machine Learning, Data Science",
            "id": 3
        },
        {
            "postTitle": "Feedfowrward Neural Networks and their Creation in Python",
            "postLines": [
                {"line": "Today we will try to understand the operation of Feedforward neural networks, by constructing a simple example of such a network in Python.", "code": false},
                {"line": "Even though Machine Learning's mathematical engine is a complex concept to comprehend, in today's example only the ability to multiply matrices is required to grasp the idea.", "code": false},
                {"line": "If you ever want to go into Machine Learning industry, learning statistics would be a wise choice for setting your knowlege base as a neural network is a statistical computational model. You can think of it as a system of neurons connected by synapses that send impulses (data) to each other. Data travels across these synapses - from one layer to another. A simple neural network is build upon three layers: the input layer, the hidden layer, and the output layer, as shown below, on the Diagram.", "code": false},
                {"line": "Layers Diagram", "code": false, "image": true, "src":[]},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false}
            ],
            "postTags": "",
            "id": 4.0
        },
        {
            "postTitle": "SaaS?",
            "postLines": [
                {"line": "Software as a service, or SaaS in short,  a software sharing model that has gained immense popularity in recent years. To a large extent, this is due to the continuous development of cloud technologies and the greater opportunities that subsequent innovations in this area give to the creators of computer programs. Even if you've never heard of SaaS, you probably still use the applications provided in this model every day.", "code": false},
                {"line": "It is a model of distribution of computer applications, with clients having acces to the tool they need only via Internet. The application uses the public cloud infrastructure for efficient operation, where its resources are also stored.", "code": false},
                {"line": "The SaaS model is now widely used both in business and in the private sector. Every day, many users use e-mail boxes, cloud drives and ubiquitous websites that provide libraries of movies, music or books.", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false}
            ],
            "postTags": "",
            "id": 5
        },
        {
            "postTitle": "SQL Cheatsheet",
            "postLines": [
                {"line": "", "code": false, "image": true, "src" : ["/pdfs/SQL_Queries_0.jpg", "/pdfs/SQL_Queries_1.jpg", "/pdfs/SQL_Queries_2.jpg"]},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false}
            ],
            "postTags": "",
            "id": 6
        }
    ],
    "javascript" : [
        {
            "postTitle": "What is JavaScript?",
            "postLines": [
                {"line": "JavaScript is the lifeblood of interactivity on the web, but its origins trace back to an era when the internet was still in its infancy. In 1995, a Netscape Communications engineer named Brendan Eich was tasked with creating a lightweight scripting language for the web - one that would enable developers to engance static HTML pages with dynamic behavior. The result, crafted in just ten days, was first called Mocha, then LiveScript, and finally, JavaScript - a name strategically chosen to ride the wave of Java's rising popularity, despite the two languages being fundamentally different.", "code": false},
                {"line": "Initially, JavaScript was designed as a simple tool to handle user interactions - things like validationg form inputs, responding to button clicks, or even changing webpage elements on the fly, all without requiring constant communication with a remote server. This ability to execute code directly in the browser made websites feel more alive and responsive, laying the groundwork for the dynamic, app-like experiences we now take for granted.", "code": false},
                {"line": "Over the decades, JavaScript has evolved far beyond its humble beginnings. What started as a lightweight scripting language has grown into one of the most powerful programming ecosystems, running everything from complex web applications to server-side platforms, mobile apps, and even AI-powered tools. Today, it's hard to imagine the internet without JavaScript - it has become the connective tissue of modern web development, shaping how we interact with digital experiences every day.", "code": false}
            ],
            "postTags": "JavaScript, JS, Mocha, LiveScript, JS beginnings, web history",
            "id": 1.01
        },
        {
            "postTitle": "The Essence of JavaScript: How It Works and What Defines It",
            "postLines": [
                {"line" : "JavaScript is one of the most influential programming languages in the modern web ecosystem. It enables websites to be dynamic, interactive, and user-friendly. However, unlike many traditional programming languages, JavaScript is shaped by a unique set of characteristics that define both its strengths and limitations."},
                {"line" : "Client-Side Execution: An Interpreted Language", "code": false, "subtitle": true},
                {"line": "One of JavaScript’s core traits is that it is an interpreted language, meaning that it does not require a separate compilation step before execution. Instead, the browser reads and executes JavaScript code directly on the client’s machine, making web applications more responsive and reducing the need for constant communication with a remote server. This approach allows for real-time interactions, such as instant form validation, dynamic content updates, and animated user interfaces.", "code": false, "subtitle": false},
                {"line": "An Object-Based, Not Fully Object-Oriented Language", "code": false, "subtitle": true},
                {"line": "JavaScript is often described as an object-based language, as it heavily relies on built-in objects like Date, Array, and Math to perform various operations. However, in its original form, JavaScript did not support traditional Object-oriented programming (OOP) mechanisms such as classical inheritance found in languages like Java or C++. Instead, it introduced a prototype-based inheritance model, where objects can inherit properties and methods directly from other objects rather than through structured class hierarchies. This makes JavaScript highly flexible but also distinct from strictly object-oriented languages.", "code": false, "subtitle": false},
                {"line": "Embedded Within HTML: The Power of Integration", "code": false, "subtitle": true},
                {"line": "Unlike standalone programming languages, JavaScript is embedded directly within HTML. This means that JavaScript code can be placed inside <script> tags within an HTML document, allowing it to manipulate webpage elements in real-time. This seamless integration with HTML and CSS makes JavaScript an essential tool for web developers, enabling them to create dynamic pages that respond to user input without requiring a page reload."},
                {"line": "Dynamic Typing: No Need for Explicit Variable Declarations", "code": false, "subtitle": true},
                {"line": "Another defining feature of JavaScript is its loosely typed nature. Unlike languages that require explicit type declarations, JavaScript allows developers to create variables without specifying their data type. A variable can hold a number at one moment ans a string the next, offering significant flexibility. However, this dynamic typing can also lead to unexpected bugs if not handled carefully.", "code": false, "subtitle": false},
                {"line": "let data = 10; // Initially a number", "code": true, "subtitle": false},
                {"line": "data = \"Now I'm a string :)\"; //Reassigned as a string", "code": true, "subtitle": false},
                {"line": "Runtime Execution: Functions and Objects Are Resolved on the Fly", "code": false, "subtitle": true},
                {"line": "In JavaScript, function calls and object references are resolved during execution rather than at compile time. This characteristic, known as late binding, allows developers to define functions and objects on the go, which is particularly useful for dynamic applications. However, it also means that errors may only become apparent at runtime, requiring careful debugging.", "code": false, "subtitle": false},
                {"line": "Security Constraints: No Direct Access to the Local Filesystem", "code": false, "subtitle": true},
                {"line": "For security reasons, JavaScript operates in a sandboxed environment within the browser. This means that JavaScript cannot write to the user's harddrive or make unrestricted changes to the local system. While this limitation prevents potential security threats, it also restricts JavaScript from performing certain tasks that server-side languages like Python or Java can handle.", "code": false, "subtitle":true},
                {"line": "Conclusion: A Language That Continues to Evolve", "code": false, "subtitle": true},
                {"line": "JavaScript’s unique structure—interpreted, object-based, embedded in HTML, dynamically typed, and sandboxed—has made it an indispensable tool for web development. Despite its original limitations, JavaScript has continued to evolve, introducing features like modern ES6 classes, modules, and asynchronous programming to enhance its capabilities. Today, it powers everything from simple web animations to complex server-side applications, proving that its flexibility and adaptability have made it one of the most enduring languages of the digital era."}
            ],
            "postTags": "JavaScript, JS, features of JavaScript",
            "id": 1.01
        },
        {
            "postTitle": "Asynchronous Programming in JavaScript: a Guide to Non-Blocking Code",
            "postLines": [
                {"line": "JavaScript is known for its ability to create dynamic and interactive web applications. However, one of its most powerful yet often misunderstood features is asynchronous programming. Without it, modern applications would freeze while waiting for tasks like fetching data, reading files, or interacting with APIs.", "code": false, "subtitle": false},
                {"line": "But what exactly is asynchronous programming, and why is it so essential in JavaScript? Let’s break it down.", "code": false, "subtitle": false},
                {}
            ]
        },
        {
            "postTitle": "Assigning values of one object onto another.",
            "postLines": [
                {"line": "var objA = {", 
                "code": true},
                {"line": "   age: '8',", "code": true},
                {"line": "   city: 'Porto'", "code": true},
                {"line": "};", "code": true},
                {"line": "var objB ={", "code": true},
                {"line": "   age: '6',", "code": true},
                {"line": "   city: 'Paris',", "code": true},
                {"line": "   experience: '1'", "code": true},
                {"line": "};", "code": true},
                {"line": "var objC =", "code": true},
                {"line": "Object.assign({}, objA, objB);", "code": true},
                {"line": "", "code": false},
                {"line": "output: ", "code": false},
                {"line": "{age: '6',", "code": true},
                {"line": " city: 'Paris',", "code": true},
                {"line": " experience: '1'}", "code": true}
            ],
            "postTags": "object, Object.assign(), copying objects",
            "id": 1.10 
        },
        {
            "postTitle": "The switch statement.",
            "postLines": [
                {"line": "var day = 7;", "code": true},
                {"line": "switch(day){", "code": true},
                {"line": "   case 1:", "code": true},
                {"line": "      document.write('Mon');", "code": true},
                {"line": "      break;", "code": true},
                {"line": "   case 2:", "code": true},
                {"line": "      document.write('Tue');", "code": true},
                {"line": "      break;", "code": true},
                {"line": "   case 3:", "code": true},
                {"line": "      document.write('Wed');", "code": true},
                {"line": "      break;", "code": true},
                {"line": "   case 4:", "code": true},
                {"line": "      document.write('Thu');", "code": true},
                {"line": "      break;", "code": true},
                {"line": "   case 5:", "code": true},
                {"line": "      document.write('Fri');", "code": true},
                {"line": "      break;", "code": true},
                {"line": "   case 6:", "code": true},
                {"line": "      document.write('Sat');", "code": true},
                {"line": "      break;", "code": true},
                {"line": "   case 7:", "code": true},
                {"line": "      document.write('Sun');", "code": true},
                {"line": "Output: Sun", "code": false}
            ],
            "postTags": "switch, break, document.write()",
            "id": 2
        },
        {
            "postTitle": " Looping over a Map() object.",
            "postLines": [
                {"line": "let zoo = new Map();", "code": true},
                {"line": "", "code": true},
                {"line": "zoo.set('Zebra', 5);", "code": true},
                {"line": "zoo.set('Gorilla', 2);", "code": true},
                {"line": "zoo.set('Monkey', 76);", "code": true},
                {"line": "", "code": true},
                {"line": "console.log(zoo);", "code": true},
                {"line": "", "code": true},
                {"line": "let zebraCount = zoo.get('Zebra');", "code": true},
                {"line": "console.log(zebraCount);", "code": true},
                {"line": "", "code": true},
                {"line": "for (let[key, value] of zoo) {", "code": true},
                {"line": "  console.log(key + ':' + value)", "code": true},
                {"line": "}", "code": true},
                {"line": "", "code": false},
                {"line": "output:", "code": false},
                {"line": "Map() {'Zebra' => 5, 'Gorilla' => 2, 'Monkey' => 76}", "code": false},
                {"line": "5", "code": false}
            ],
            "postTags": "Map() object, Map.get(), key and value of Map()",
            "id": 3
        },
        {
            "postTitle": " Map() Object in JavaScript",
            "postLines": [
                {"line": "Since EcmaScript 6 we have new classes, which can facilitate working with collections. Map and WeakMap are just two of these classes.", "code": false},
                {"line": "All objects in JavaScript can be looked at as we do at Map() objects. An Object, in summary, consists of properties and values. We could think of them like of keys and values.", "code": false},
                {"line": "", "code": true},
                {"line": "var obj = new Object();", "code": true},
                {"line": "obj.a = 1;", "code": true},
                {"line": "obj.b = 2;", "code": true},
                {"line": "obj[0] = 3;", "code": true},
                {"line": "", "code": false},
                {"line": "console.log(obj['a']);", "code": true},
                {"line": "console.log(obj['b']);", "code": true},
                {"line": "console.log(obj[0]);", "code": true},
                {"line": "", "code": false},
                {"line": "console.log(obj);", "code": true},
                {"line": "", "code": false},
                {"line": "Output:", "code": false},
                {"line": "1", "code": true},
                {"line": "2", "code": true},
                {"line": "3", "code": true},
                {"line": "{0: 3, a: 1, b: 2}", "code": true},
                {"line": "", "code": false},
                {"line": "The below more advanced example treats the whole object as a key.", "code": false},
                {"line": "", "code": false},
                {"line": "var obj = new Object();", "code": true},
                {"line": "var objKey = ({id: 1});", "code": true},
                {"line": "obj[objKey] = 4;", "code": true},
                {"line": "console.log(obj[objKey]);", "code": true},
                {"line": "console.log(Object", "code": true},
                {"line": ".getOwnPropertyNames(obj));", "code": true},
                {"line": "", "code": false},
                {"line": "Output:", "code": false},
                {"line": "4", "code": true},
                {"line": "['[object Object]']", "code": true},
                {"line": "Which seems a bit odd due to the ['[object Object]'] index.", "code": false},
                {"line": "", "code": false},
                {"line": "As we can see a JavaScript object cannot be treated as a dictionary.", "code": false},
                {"line": "And this is the reason to use the classes Map and WeakMap. So, what makes the WeakMap class so weak?", "code": false},
                {"line": "Let's assume, that an object as a key in WeakMap exists. Later all references to this object in JavaScript disappear at some point. JavaScript engine will remove the references from WeakMap.", "code": false},
                {"line": "Meaning WeakMap does not remember this object strongly. When object are to be cleared, then these will be automatically removed from WeakMap. Keys in WeakMap are not permanent. It is one of the reasons why we don't perform iterations over keys of WeakMap and showing all the variables stored in WeakMap can prove cumbersome.", "code": false},
                {"line": "Below we have an example of an ordinary map. We create keys which are of object type and set their values. In the next step we try to get a specified value.", "code": false},
                {"line": "let user1 = {name: 'Cesar'};", "code": true},
                {"line": "let user2 = {name: 'Kate'};", "code": true},
                {"line": "", "code": false},
                {"line": "let users = new Map();", "code": true},
                {"line": "users.set(user1, 'Designer');", "code": true},
                {"line": "users.set(user2, 'Developer');", "code": true},
                {"line": "", "code": false},
                {"line": "console.log(users.get(user1));", "code": true},
                {"line": "Output: Designer", "code": false}



            ],
            "postTags": "",
            "id": 4
        },
        {
            "postTitle": " Post",
            "postLines": [
                {"line": "", "code": false},
                {"line": "", "code": true}
            ],
            "postTags": "",
            "id": 5
        },
        {
            "postTitle": " Post",
            "postLines": [
                {"line": "", "code": false},
                {"line": "", "code": true}
            ],
            "postTags": "",
            "id": 6
        }
    ],
    "python" : [
        {
            "postTitle": "Python Syntax",
            "postLines": [
                {"line": "Python syntax or any programming language syntax is a set of rules to be followed in order for our code to be well understandable and executed in the way we intend it to work.", "code": false},
                {"line": "print(2+4)", "code": true},
                {"line": "Output: 6", "code": true},
                {"line": "Addition of floats returns a floating point number (float).", "code": false},
                {"line": "print(2.0 + 5.111)", "code": true},
                {"line": "Output: 7.111", "code": true},
                {"line": "Adding an integer and a float will include the value after the point of the float returning a float.", "code": false},
                {"line": "print(6 + 7.111)", "code": true},
                {"line": "Output: 13.111", "code": true},
                {"line": "print(2 + 5.0)", "code": true},
                {"line": "Output: 7.0 #Instead of 7.", "code": true}
            ],
            "postTags": "",
            "id": 1.03
        },
        {
            "postTitle": "Numbers - Integers and Floats",
            "postLines": [
                {"line": "Integers are whole numbers, floats are also numbers, but hold a value after the point which can be zero as well, e.g. 2.0 or 5.111.", "code": false},
                {"line": "Addition of integers returns an integer.", "code": false},
                {"line": "print(2+4)", "code": true},
                {"line": "Output: 6", "code": true},
                {"line": "Addition of floats returns a floating point number (float).", "code": false},
                {"line": "print(2.0 + 5.111)", "code": true},
                {"line": "Output: 7.111", "code": true},
                {"line": "Adding an integer and a float will include the value after the point of the float returning a float.", "code": false},
                {"line": "print(6 + 7.111)", "code": true},
                {"line": "Output: 13.111", "code": true},
                {"line": "print(2 + 5.0)", "code": true},
                {"line": "Output: 7.0 #Instead of 7.", "code": true}
            ],
            "postTags": "",
            "id": 1.09
        },
        {
            "postTitle": "Types - determining the type of a variable",
            "postLines": [
                {"line": "Determining the type of a variable", "code": false},
                {"line": "print(2+4)", "code": true},
                {"line": "Output: 6", "code": true},
                {"line": "Addition of floats returns a floating point number (float).", "code": false},
                {"line": "print(2.0 + 5.111)", "code": true},
                {"line": "Output: 7.111", "code": true},
                {"line": "Adding an integer and a float will include the value after the point of the float returning a float.", "code": false},
                {"line": "print(6 + 7.111)", "code": true},
                {"line": "Output: 13.111", "code": true},
                {"line": "print(2 + 5.0)", "code": true},
                {"line": "Output: 7.0 #Instead of 7.", "code": true}
            ],
            "postTags": "",
            "id": 1.01
        },
        {
            "postTitle": "Arrays - Basics",
            "postLines": [
                {"line": "Array is a sort of a box that contains values, usually separated by a comma. In Python those values can be of different type, unlike in C++, where the values must be of the same type.", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": true}
            ],
            "postTags": "",
            "id": 2.0
        },
        {
            "postTitle": "PyGym - Exercise 2.0",
            "postLines": [
                {"line": "Write a program that displays two arbitrary messages to the screen.", "code": false},
                {"line": "", "code": true}
            ],
            "postTags": "",
            "id": 2.0
        },
        {
            "postTitle": "PyGym - Exercise 2.1",
            "postLines": [
                {"line": "Write a program that asks the user for their name and year of birth, then calculates and prints their age.", "code": false},
                {"line": "Examplary execution:", "code": false},
                {"line": "Give your name:", "code": false},
                {"line": "Johnny", "code": false},
                {"line": "Enter year of birth:", "code": false},
                {"line": "1989", "code": false},
                {"line": "John, you are 30 years old.", "code": false}
            ],
            "postTags": "",
            "id": 2.1
        },
        {
            "postTitle": "PyGym Exercise 2.2",
            "postLines": [
                {"line": "Write a program that asks the user for their name and year of birth, then calculates and prints their age.", "code": false},
                {"line": "Examplary execution:", "code": false},
                {"line": "Give your name:", "code": false},
                {"line": "Johnny", "code": false},
                {"line": "Enter year of birth:", "code": false},
                {"line": "1989", "code": false},
                {"line": "John, you are 30 years old.", "code": false}
            ],
            "postTags": "",
            "id": 2.2
        },
        {
            "postTitle": "Working with Files in Python",
            "postLines": [
                {"line": "Reading and Writing to Files", "code": false},
                {"line": "The process of reading and writing data to a file is a complex task. Python, like most programming languages, allows for loading data from external sets and save data to files. The reading process can be carried out using the built-in functions open(), read() and close() or - in the case of data with a fixed structure - usually tabular, you can use ready-made functions supporting this process. First, we will analyze the process of reading data using built-in functions and then we will show an example of external solutions.", "code": false},
                {"line": "To read a text file, you need to execute three commands: ", "code": false},
                {"line": "open() to connect to the file (nothing is loaded)", "code": false},
                {"line": "read() to read the entire contents of the file into one variable as text", "code": false},
                {"line": "close() to close the file after reading is complete", "code": false},
                {"line": "In addition, the reading or writing process requires finding the correct file, or - in the case of reading - creating a new file.", "code": false},
                {"line": "As an example, we'll load a small text file from the same directory as our script.", "code": false},
                {"line": "# -*- coding: utf -8 -*-", "code": true},
                {"line": "f = open('file.txt')", "code": true},
                {"line": "contents = f.read()", "code": true},
                {"line": "f.close()", "code": true},
                {"line": "contents", "code": true},
                {"line": "'This is the content of the file\nLine 2\nLine 3\n\nThere is an empty line above.\n'"},
                {"line": "The open() function connects to the file but does not load the data. It only assigns a file pointer to the object f. This is due to the fact that the data set can be very large and the programmer should keep control over its loading. The read() function reads all the content from source f(file) into the variable content. Then the source is closed.", "code": false},
                {"line": "The '\n' character within the variable means the end of the line, to break such a line into separate ones, use the split() function, indicating the character used for breaking.", "code": false},
                {"line": "contents.split('\n')", "code": true},
                {"line": "#Out: ['This is the content of the file',", "code": true},
                {"line": "'Line 2',", "code": true},
                {"line": "'Line 3',", "code": true},
                {"line": "'',", "code": true},
                {"line": "'There is an empty line above.'", "code": true},
                {"line": "'']", "code": true},
                {"line": "For large files, it is better to use a line-by-line reading procedure. Reading line by line is also an operation used when we want to read specific lines from a file:", "code": false},
                {"line": "f = open('file.txt')", "code": true},
                {"line": "f.readline()", "code": true},
                {"line": "f.readline()", "code": true},
                {"line": "f.readline()", "code": true},
                {"line": "f.close()", "code": true},
                {"line": "#Out: 'This is the content of the file\n'", "code": true},
                {"line": "Line 2\n", "code": true},
                {"line": "Line 3\n", "code": true},
                {"line": "This way we can control which lines are saved for further processing.", "code": false},
                {"line": "The open() function by default opens a text file for reading, thus calling open() is equivalent to open(file, 'rt'). Files can also be opened in other modes, such as binary mode ('b') or write mode ('w'), write and append mode ('a'), or create new file mode ('x').", "code": false},
                {"line": "Reading and Processing Tabular Files", "code": false},
                {"line": "Since Python loads data in the form of a single text variable, if we intend to calculate the loaded data, it should be appropriately transformed, usually in tabular form, and the data types should be modified from text to numeric. The already known split() and variable conversion functions are used for this purpose. The procedure for reading data is as follows:", "code": false},
                {"line": "1. In the first step, a connection to the file is established (the content is displayed).", "code": false},
                {"line": "2. The data is divided into a list of text strings, relative to the '\n' character, and then each line is divided into internal lists based on a comma (separator in csv). The result is displayed as a nested list.", "code": false},
                {"line": "3. The connection is closed.", "code": false},
                {"line": "4. 1 line (header) is removed from the list.", "code": false},
                {"line": "5. The last empty line is removed from the list (usually found in text files).", "code": false},
                {"line": "f = open('tab.csv') #1", "code": true},
                {"line": "data = f.read()", "code": true},
                {"line": "data", "code": true},
                {"line": "data = data.split('\n') #divide by lines", "code": true},
                {"line": "data = [l.split(',') for l in dane] #2", "code": true},
                {"line": "data", "code": true},
                {"line": "f.close() #3", "code": true},
                {"line": "header = data.pop(0) #4", "code": true},
                {"line": "data.pop() #5", "code": true},
                {"line": "Out: 'Street, House_no, code, city\nGrasshopers, 20, W1S L20, Grassfields\nLadybirds, 15, Z81 S22, Sunshines\nBeetles, 10, UL1 SW2, Beetlejuices\n'", "code": true},
                {"line": "Out: [['Street', 'House_no', 'code', 'city'],", "code": true},
                {"line": "      ['Grasshopers', ' 20', ' W1S L20', ' Grassfields'],", "code": true},
                {"line": "      ['Ladybirds', ' 15', ' Z81 S22', ' Sunshines'],", "code": true},
                {"line": "      ['Beetles', ' 10', ' UL1 SW2', ' Beetlejuices'],", "code": true},
                {"line": "      ['']]", "code": true},
                {"line": "Out: ['']", "code": true},
                {"line": "Data is stored as a list of lists, where each nested list is a single row of different types of data. Since it is not convenient to operate on rows containing different types of data, the nested lists can be transrormed into a columnar form (transposed) using the zip() function. The data is passed with *, i.e. we expand the passed list to the following form: data[0], data[1], ..., data[n-1].", "code": false},
                {"line": "data = zip(*data)", "code": true},
                {"line": "trans = list(data)", "code": true},
                {"line": "trans", "code": true},
                {"line": "Out: [('Grasshopers', 'Ladybirds', 'Beetles'),", "code": true},
                {"line": "      (' 20', ' 15', ' 10'),", "code": true},
                {"line": "      (' W1S L20', ' Z81 S22', ' UL1 SW2'),", "code": true},
                {"line": "      (' Grassfields', ' Sunshines', ' Beetlejuices')]", "code": true},
                {"line": "in the last step the second and third lines can be casted into integer type. Here, the mapping function comes in handy:", "code": false},
                {"line": "numbers = tuple(map(int, trans[1]))", "code": true},
                {"line": "numbers", "code": true},
                {"line": "Out: (20, 15, 10)", "code": true},
                {"line": "Using the csv reader Function", "code": false},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true}

            ],
            "postTags": "",
            "id": 4.0
        }, 
        {
            "postTitle": "Object-Oriented Programming in Python: A Comprehensive Guide",
            "postLines": [
                {
                    "line": "Introduction", "code": false, "subtitle": true
                },
                {"line": "Object-Oriented Programming (OOP) is a fundamental programming paradigm that structures software design around objects rather than functions and logic. Python, being a versatile and widely-used language, fully supports OOP principles, making it an excellent choice for developers seeking to build scalable and maintainable applications. This article provides an in-depth exploration of OOP in Python, covering its core concepts, benefits, and best practices.", "code":false, "subtitle":false},
                {"line": "Understanding Objects and Classes", "code": false, "subtitle": true},
                {"line": "At the heart of OOP lies the concept of objects and classes. A class is a blueprint for creating objects, encapsulating data (attributes) and behavior (methods). Objects are specific instances of classes.", "code": false, "subtitle": false},
                {"line": "Defining a Class and Creating an Object", "code": false, "subsubtitle": true},
                {"line": "class Car:", "code": true},
                {"line": " ", "code": true},
                {"line": "   def __init__(self, brand, model, year):", "code": true},
                {"line": "      self.brand = brand", "code": true},
                {"line": "      self.model = model", "code": true},
                {"line": "      self.year = year", "code": true},
                {"line": " ", "code": true},
                {"line": "   def display_info(self):", "code": true},
                {"line": "      return f\"{self.year} {self.brand} {self.model}", "code": true},
                {"line": " ", "code": true},
                {"line": "# Creating an object", "code": true},
                {"line": "my_car = Car(\"Tesla\", \"Model S\", 2022)", "code": true},
                {"line": "print(my_car.display_info())", "code": true},
                {"line": "Core OOP Principles in Python", "subtitle": true},
                {"line": "1. Encapsulation", "subsubtitle": true},
                {"line": "Encapsulation is the practice of restricting direct access to some aspects of an object, typically by using private variables and providing controlled access through methods."},
                {"line": "class BankAccount:", "code":true},
                {"line": "   def __init__(self, owner, balance):", "code": true},
                {"line": "      self.owner = owner", "code": true},
                {"line": "      self.__balance = balance  # Private variable", "code": true},
                {"line": " ", "code": true},
                {"line": "   def deposit(self, amount):", "code": true},
                {"line": "      if amount > 0:", "code":true},
                {"line": "         self.__balance += amount", "code": true},
                {"line": " ", "code": true},
                {"line": "   def withdraw(self, amount):", "code": true},
                {"line": "      if 0 < amount <= self.__balance:", "code": true},
                {"line": "         self.__balance -= amount", "code": true},
                {"line": "      else:", "code": true},
                {"line": "         print(\"Insufficient funds\")", "code": true},
                {"line": " ", "code": true},
                {"line": "   def get_balance(self):", "code": true},
                {"line": "      return self.__balance", "code": true},
                {"line": " ", "code": true},
                {"line": "# Usage", "code": true},
                {"line": "account = BankAccount(\"Alice\", 1000)", "code": true},
                {"line": "account.deposit(500)", "code":true},
                {"line": "print(account.get_balance()", "code": true},
                {"line": "2. Inheritance", "subsubtitle": true},
                {"line": "Inheritance allows a class to derive attributes and methods from another class, promoting code reuse.", "code":false},
                {"line": "class Vehicle:", "code": true},
                {"line": "   def __init__(self, brand):", "code": true},
                {"line": "      self.brand = brand", "code": true},
                {"line": " ", "code": true},
                {"line": "   def honk(self):", "code": true},
                {"line": "      return \"Honk! Honk!\"", "code": true},
                {"line": " ", "code": true},
                {"line": "class Car(Vehicle):", "code": true},
                {"line": "   def __init__(self, brand, model):", "code": true},
                {"line": "      super().__init__(brand)", "code": true},
                {"line": "      self.model = model", "code": true},
                {"line": " ", "code": true},
                {"line": "# Using inheritance", "code": true},
                {"line": "car = Car(\"Toyota\", \"Corolla\")", "code": true},
                {"line": "print(car.honk()) # Output: Honk! Honk!", "code": true},
                {"line": "3. Polymorphism", "subsubtitle": true},
                {"line": "Polymorphism enables methods in different classes to have the same name but different implementations."},
                {"line": "class Bird:", "code": true},
                {"line": "   def sound(self):", "code": true},
                {"line": "      return \"Chirp!\"", "code": true},
                {"line": " ", "code": true},
                {"line": "class Dog:", "code": true},
                {"line": "   def sound(self):", "code": true},
                {"line": "      return \"Bark!\"", "code": true},
                {"line": " ", "code": true},
                {"line": "def make_sound(animal):", "code": true},
                {"line": "   print(animal.sound())", "code": true},
                {"line": " ", "code": true},
                {"line": "# Using polymorphism", "code": true},
                {"line": "parrot = Bird()", "code": true},
                {"line": "dog = Dog()", "code": true},
                {"line": "make_sound(parrot)  # Output: Chirp!", "code": true},
                {"line": "make_sound(dog)  # Output: Bark!", "code": true},
                {"line": "4. Abstraction", "subsubtitle": true},
                {"line": "Abstraction allows hiding implementation details while exposing only the necessary functionality.", "code": false},
                {"line": "from abc import ABC, abstractmethod", "code": true},
                {"line": " ", "code": true},
                {"line": "class Animal(ABC):", "code": true},
                {"line": "   @abstractmethod", "code": true},
                {"line": "   def make_sound(self):", "code": true},
                {"line": "      pass", "code": true},
                {"line": " ", "code": true},
                {"line": "class Cat(Animal):", "code": true},
                {"line": "   def make_sound(self):", "code":true},
                {"line": "      return \"Meow!\"", "code": true},
                {"line": "Advantages of OOP in Python", "subtitle": true},
                {"line": " ⸰ Modularity: Encourages code organization through reusable classes.", "code":false},
                {"line": " ⸰ Scalability: Facilitates the expansion of applications without major code changes.", "code":false},
                {"line": " ⸰ Maintainability: Improves code readability and debugging."},
                {"line": " ⸰ Encapsulation: Enhances security by restricting access to sensitive data."},
                {"line": "Best Practices for OOP in Python", "subtitle": true},
                {"line": " ⸰ Follow Naming Conventions: Use CamelCase for class names and snake_case for methods and variables."},
                {"line": " ⸰ Use Docstrings: Document class and method functionalities."},
                {"line": " ⸰ Avoid Large Classes: Keep classes focused on a single responsibility."},
                {"line": " ⸰ Lavarage Composition: Prefer composition over deep inheritance to enhance flexibility."},
                {"line": "Conclusion", "subtitle": true},
                {"line": "Object-Oriented Programming in Python provides a powerful way to structure software, enhancing code readability, reausability, and scalability. By understanding and applying core OOP principles such as encapsulation, inheritance, polymorphism, and abstraction, developers can create robust applications that stand the test of time. Whether building small scripts or large-scale systems, mastering OOP in Python is an invaluable skill that significantly improves software development efficiency and effectiveness."}
            ]
        },
        {
            "postTitle": "Understanding GeoCityLite - A Lightweight Geolocation Database for Python Applications",
            "postLines": [
                {"line": "In an era where digital interactions are increasingly location-aware, the need for efficient geolocation tools has never been greater. One such tool that stands out for it's balance betweem performance and accessibility is GeoCityLite, a lightweight geolocation database that enables developers to determine the geographic location of IP addresses. This article explores what GeoCityLite is, it's significance, and how it can be effectively leveraged in Python applications."},
                {"line": "What is GeoCityLite", "subtitle": true}, 
                {"line": "GeoCityLite is a freely available, IP-based geolocation database provided by MaxMind, a leading provider of geolocation services. It offers city-level location data for a given IP address, including details such as country, region, latitude, longitude, and time zone. While GeoCityLite is a free and more limited version of MaxMind's GeoIP2 database, it remains a valuable tool for developers who require essential geolocation capabilities without the cost of premium solutions."},
                {"line": "GeoCityLite databases are distributed in GeoIP2 format and can be queried using specialized libraries such as MaxMind's geoip2 Python package. The database is periodically updated to reflect changes in IP-to location mappings, ensuring relatively accurate geolocation data."},
                {"line": "Use Cases of GeoCityLite in Python", "subtitle": true},
                {"line": "GeoCityLite's flexibility makes it useful in a wide array of applications. Below are some prominent use cases:"}, 
                {"line": "1. Personalizing Content Based on Location", "subsubtitle": true},
                {"line": "Web applications and services can use GeoCityLite to deliver location-specific content. For example, an e-commenrce platform can customize product recommendations, language settings, or currency display based on the user's geographical location."},
                {"line": "2. Enhancing Security with IP-Based Restrictions", "subsubtitle": true},
                {"line": "Cybersecurity applications can utilize GeoCityLite to enforce location-based access restrictions. Financial institutions, for instance, can flag login attempts from unusual locations as potential security threats, adding an extra layer of protection against fraud."},
                {"line": "3. Optimizing Web Traffic Analytics", "subsubtitle": true},
                {"line": "Businesses can analyze website traffic by determining visitor locations, enabling them to make informed marketing and operational decisions. Insights derived from geolocation data can help companies target specific demographics more effectively."},
                {"line": "Improving Performance with CDN Routing", "subsubtitle":true},
                {"line": "Content Delivery Networks (CDNs) and clound services can leverage GeoCityLite to direct users to the nearest server location, thereby reducing latency and improving overall performance."},
                {"line": "5. Geospacial Data Enrichment", "subsubtitle": true},
                {"line": "Data scientists can enhance datasets by adding geolocation attributes, facilitating advanced geographical analysis in various domains such as epidemiology, urban planning, and logistics."},
                {"line": "Implementing GeoCityLite in Python", "subtitle": "true"},
                {"line": "Integrating GeoCityLite into a Python application is straightforward with the geoip2 library. Below is an example demonstrating how to query multiple IP addresses, handle exceptions, and log results:"},
                {"line": "installation", "subsubtitle": true},
                {"line": "To begin, install the necessary library using pip:"},
                {"line": "pip install geoip2", "code": true},
                {"line": "Downloading the Database", "subsubtitle": true},
                {"line": "Download the latest GeoCityLite database from MaxMind's official website and extract the .mmdb file."},
                {"line": "Querying Multiple IP Addresses with Error Handling and Logging", "subsubtitle": true},
                {"line": "import geoip2.database", "code": true},
                {"line": "import logging", "code": true},
                {"line": " ", "code": true},
                {"line": "# Configure logging", "code": true},
                {"line": "logging.basicConfig(filename='geolocation.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')", "code": true},
                {"line": " ", "code": true}, 
                {"line": "def get_location(ip, reader):", "code": true},
                {"line": "   try:", "code": true},
                {"line": "      response = reader.city(ip)", "code": true},
                {"line": "      return {", "code": true},
                {"line": "         'IP': ip,", "code": true},
                {"line": "         'City': response.city.name,", "code": true},
                {"line": "         'Region': response.subdivisions.most_specific.name,", "code": true},
                {"line": "         'Country': response.country.name,", "code": true},
                {"line": "         'Latitude': response.location.latitude,", "code": true},
                {"line": "         'Longitude': response.location.longitude,", "code": true},
                {"line": "         'Time Zone': response.location.time_zone,", "code": true},
                {"line": "      }", "code": true},
                {"line": "   except Exception as e:", "code": true},
                {"line": "      logging.error(f\"Error retrieving location for {ip}: {e}\")", "code": true},
                {"line": "      return {'IP': ip, 'Error': 'Could not retrieve location'}"},
                {"line": " ", "code": true},
                {"line": "# Load the database", "code": true},
                {"line": "reader = geoip2.database.Reader('GeoLite2-City.mmdb')", "code": true},
                {"line": " ", "code": true},
                {"line": "# List of IPs to query", "code": true},
                {"line": "ip_addresses = ['8.8.8.8', '1.1.1.1', '192.168.1.1']", "code": true},
                {"line": " ", "code": true},
                {"line": "# Fetch geolocation data for each IP", "code": true},
                {"line": "locations = [get_location(ip, reader) for ip in ip_addresses]", "code": true},
                {"line": " ", "code": true},
                {"line": "# Print results", "code": true},
                {"line": "for loc in locations:", "code": true},
                {"line": "   print(loc)", "code": true},
                {"line": " ", "code": true},
                {"line": "# Close the database reader", "code": true},
                {"line": "reader.close()", "code": true},
                {"line": "Explanation", "subtitle": true},
                {"line": "1. Handling Multiple IPs: The script queries multiple IP addresses in a loop."},
                {"line": "2. Exception Handling: If an error occurs (e.g. private IP, incorrect format), the error is logged, and a fallback response is returned."},
                {"line": "3. Logging: Errors are logged for debugging and monitoring purposes."},
                {"line": "Conclusion", "subtitle": true},
                {"line": "GeoCityLite serves as an efficient and accessible solution for incorporating geolocation functionality into Python applications. Whether for personalizing user experiences, strengthening cybersecurity, or optimizing analytics, its applications are diverse and impactful. By leveraging the geopi2 library, developers can seamlessly integrate IP-based geolocation capabilities into their projects, making their applications more intelligent and context-aware."},
                {"line": "For more advanced features, developers may consider upgrading to MaxMind's premium databases, but for many use cases, GeoCityLite remains a powerful, cost-effective choice."}
            ]
        }
    ],
    "cpp" : [
        {
            "postTitle": "First C++ Program",
            "postLines": [
                {"line": "#include <iostream>", "code": true},
                {"line": "using namespace std;", "code": true},
                {"line": "int main()", "code": true},
                {"line": "{", "code": true},
                {"line": "   char a;", "code": true},
                {"line": "   cout << 'Cpp - Practical Exercises';", "code": true},
                {"line": "   cin >> a;", "code": true},
                {"line": "   return 0;", "code": true},
                {"line": "}", "code": true},
                {"line": "", "code": true}
            ],
            "postTags": "",
            "id": 2.1
        },
        {
            "postTitle": "Functions in C++",
            "postLines": [
                {"line": "Functions make our code more readable, less as they say 'like macaroni cheese'. They are separate parts of a program that perform specific tasks.", "code": false},
                {"line": "An example of using a function can be a program simulating the operation of a simple calculator. It performs operations such as addition, substraction, multiplication and division.", "code": false},
                {"line": "Each of these calculations can be separated from the main part of the program by enclosing them in four separate functions.", "code": false},
                {"line": "Function Structure", "code": false},
                {"line": "type of returned value name (list of types and names of arguments){", "code": true},
                {"line": "instructions;", "code": true},
                {"line": "}", "code": true},
                {"line": "Type of Returned Value", "code": false},
                {"line": "A function may but doesn't have to return a value in one of the forms known in Cpp, eg: int, float, char, string, bool. If, however, our function is not to return anything we simply implement a special 'void' type.", "code": false},
                {"line": "List of Types and Names of Arguments", "code": true},
                {"line": "We placethe argument list in the parentheses, after the function name. If the function is not to take any arguments, we leave the parentheses blank.", "code": false},
                {"line": "Example 1: ","code": false},
                {"line": "int addition (int first, int second) {", "code": true},
                {"line": "   int result = first + second;", "code": true},
                {"line": "   return result;", "code": true},
                {"line": "The above function accepts two arguments of type int named 'first'and 'second'. The returned value is the sum of these two."}

            ]
        },
        {
            "postTitle": "While Loop",
            "postLines": [
                {"line": "The while loop is something between a for loop and a do while loop and can also be a means to translate an if statement into a shorter form. It's main feature in common with the for loop is the condition being checked at the beginning of the loop, meaning that it does not necessarily run at all. On the other hand the do while loop runs at least once, if the condition is realistic in current settings.", "code": false},
                {"line": "The while loop, like the for loop and the do while loop, allows for repetition of a statement as long as the end condition is met. Semantically, the while loop can be written as follows:", "code": false},
                {"line": "while(end condition)", "code": true},
                {"line": "{statement list}", "code": true},
                {"line": "First of all, the condition is written at the very beginning of the loop and so it is checked before anything else is executed, and that way if the condition is not fulfilled, nothing is done.", "code": false},
                {"line": "It is worth noting that the curly braces are not required when we want to execute only one statement, whereas in the do while loop, braces are required even for only one statement.", "code": false},
                {"line": "Another thing to remember is that there is no semicolon after the curly braces, whereas in the case of the do while loop, the semicolon is there.", "code": false},
                {"line": "Simple examples of using the while loop:", "code": false},
                {"line": "#include <iostream>", "code": true},
                {"line": "using namespace std;", "code": true},
                {"line": "int main()", "code": true},
                {"line": "{", "code": true},
                {"line": "  int how_many = 6;", "code": true},
                {"line": "  while(how_many)", "code": true},
                {"line": "    cout << 'I am inside the while loop' << endl;", "code": true},
                {"line": "  cout << endl << 'Press Enter to finish.' << endl;", "code": true},
                {"line": "  getchar();     #Returns the code of the read character in case of success. The read character is returned in form of an int.", "code": true},
                {"line": "  return 0;", "code": true},
                {"line": "}", "code": true},
                {"line": "Run the above program to see that none of the inside statements get executed. Can you guess why?", "code": false},
                {"line": "And here is another example of a problematic program:", "code": false},
                {"line": "#include <iostream>", "code": true},
                {"line": "using namespace std;", "code": true},
                {"line": "int main()", "code": true},
                {"line": "{", "code": true},
                {"line": "  int how_many = 4;", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": true}
            ],
            "postTags": "",
            "id": 3.1
        }
    ],
    "data_science" : [
        {
            "postTitle": "Data Science Terminology - Statistical learning",
            "postLines": [
                {"line": "Statistical learning, also known as machine learning, is a field of study that focuses on developing algorithms and techniques to enable computers to learn from and make predictions or decisions based on data. In statistical learning, we use mathematical and statistical methods to analyze and interpret patterns and relationships in data, with the goal of creating models that can generalize well to new, unseen data.", "code": false},
                {"line": "There exist two main types of statistical learning approaches:", "code": false},
                {"line": "'Supervised Learning' in which the algorithm is trained on labeled data, where each example is associated with a target or outcome variable. The algorithm learns from the input-output pairs in the training data and aims the generalize its predictions to new, unseen data. Common tasks in supervised learning include classification (predicting categories or classes) and regression (predicting continuous values).", "code": false},
                {"line": "'Unsupervised Learning' in which the algorithm is trained on unlabeled data, where there are no predefined target variables. The goal of unsupervised learning is to uncover hidden patterns, structures, or relationships in the data. Common tasks in unsupervised learning include clustering (grouping similar data points together) and dimensionality reduction (reducing the number of features or variables while preserving important information).", "code": false},
                {"line": "Statistical learning techniques are used in a wide range of applications, including image and speech recognition, natural language processing, recommandation systems, financial modeling, and many others. The field continues to advance rapidly, driven by innovations in algorithms, computational power, and the availability of large datasets.", "code": false}
                
            ],
            "postTags": "",
            "id": 0.00
        },
        {
            "postTitle": "Data Science Terminology - Continuous vs Quantitative Output Values",
            "postLines": [
                {"line": "In statistical learning or machine learning, continuous and quantitative output values refer to the type of data that the model aims to predict or estimate.", "code": false},
                {"line": "'Continuous Output Values' are those that can take on any real number within a certain range. These values represent measurements that are not restricted to specific discrete points. For example, predicting the price of a house, the temperature, or the stock price are all examples of tasks where the output values are continuous.", "code": false},
                {"line": "'Quantitative Output Values' are similar to continuous values in that they are numeric and represent some quantity. However, they are typically more specific in nature and often represent counts or measurements of discrete objects or events. For example, predicting the number of items sold, the age of a person, or the number of defects in a manufacturing process are tasks where the output values are quantitative.", "code": false},
                {"line": "The main difference between continuous and quantitative output values lies in the nature of the data and the granularity of the predictions. Continuous output values can take on any value within a range, while quantitative output values are often counts or measurements of discrete entities or events.", "code": false},
                {"line": "However, the terms are often used interchangeably because quantitative data often involves continuous measurements.", "code": false},
                {"line": "Let's take a real life example:", "code": false},
                {"line": "Suppose we are predicting house prices based on various features like area, number of bedrooms and location. The predicted price would be a continuous output value because it can take any value within a certain range, such as $100,000 to $1,000,000. It is also a quantitative output value because it represents the amount of money, which is a quantity.", "code": false},
                {"line": "Continuous Output Value Examples:", "code": false},
                {"line": "Temperature readings can be measured with precision, such as 20.5°C or 68.3°F. The temperature can vary continuously, and there's no limit to the number of possible values.", "code": false},
                {"line": "Time is another continuous output value, where it can be measured down to fractions of a second. For example, 10:30:25.123 AM represents a precise time.", "code": false},
                {"line": "Quantitative Output Value Examples:", "code": false},
                {"line": "Number of Sales. In business, the number of sales made by a company within a certain period is a quantitative value. It represents the quantity of products of services sold.", "code": false},
                {"line": "The population of a city, country, or region is also quantitative. It represents the number of people living in that area and can be measured in millions or billions.", "code": false},
                {"line": "Inventory Levels. For a retail store, the quantity of items in inventory indicates how many units of each product are available for sale.", "code": false},
                {"line": "Test scores, such as scores on a math exam or a standardized test, represent a quantitative value of performance or proficiency level of individuals in a particular subject.", "code": false}
            ],
            "postTags": "",
            "id": 0.01
        },
        {
            "postTitle" : "Data Science Terminology - Regression Problem",
            "postLines" : [
                {"line": "Regression is a type of predictive modeling technique used in statistical learning, particularly in supervised machine learning. It's used when the target varialble, or the variable we want to predict, is continuous. In other words, regression helps us understand the relationship between one or more independent variables (also called predictors or features) and a continuous outcome variable.", "code": false },
                {"line": "The goal of regression analysis is to find the best-fitting mathematical model that describes the relationship between the independent variables and the dependent variable. This model can then be used to make predictions about the dependent variable for new data points where the independent variables are known.", "code": false},
                {"line": "For example, let's say we want to predict house prices based on factors like square footage, number of bedrooms, and location. In this case, square footage, number of bedrooms, and location would be our independent variables, and house price would be our dependent variable. We could use regression analysis to build a model that quantifies how each of these independent variables influences the house price, allowing us to make predicions about the price of a house based on its features.", "code": false},
                {"line": "There are different types of regression techniques, including linear regression, polynomial regression, and logistic regression, each suited for different types of data and relationships between variables. Linear regression, for example, assumes a linear relationship between the independent and dependent variables, while logistic regression is used when the dependent variable is binary (e.g., yes/no, true/false).", "code": false},
                {"line": "Overall, regression analysis is a powerful tool for understanding and predicting continuous outcomes based on other variables, making it widely used in fields like economics, finance, healthcare, and more.", "code": false}
            ],
            "postTags": "",
            "id" : 0.02
        },
        {
            "postTitle": "Data Science Terminology - Clustering Problem",
            "postLines": [
                {"line": "Clustering is a type of unsepervised machine learning technique used to group similar data points together based on their features or characteristics. Unlike supervised learning, where the algorithm is trained on labeled data (data with known outcomes), unsupervised learning works with unlabled data, meaning there are no predefined categories or classes.", "code": false},
                {"line": "The goal of clustering is to discover inherent structures or patterns in the data without prior knowledge of what those patterns might be. The algorithm idenrigies groups of data points that are more similar to each other than to those in other groups. These groups are called clusters.", "code": false},
                {"line": "Clustering algorithms typically measure the similarity between data points using a distance metric, such as Euclidean distance or cosine similarity. Data points that are close to each other in feature space are considered similar and are likely to be grouped together in the same cluster.", "code": false},
                {"line": "There are various clustering algorithms, each with its own approach to identifying clusters:", "code":false},
                {"line": "One of the most popular clustering algorithms is 'K-means' which partitions the data into a predefined number of clusters (K) based on the mean value of the data points in each cluster. It iteratively assigns data points to the nearest cluster centroid and updates the centroids until convergence.", "code":false},
                {"line": "'Hierarchical clustering': This algorithm builds a hierarchy of clusters by recursively merging or splitting clusters based on their similarity. It can produce dedrogram representations that show the hierarchical relationships between clusters.", "code":false},
                {"line": "'DBSCAN' (Density-Based Spation Clustering of Applications with Noise):", "code":false},
                {"line": "'Agglomerative clustering' is similar to hierarchical clustering, agglomerative clustering starts with each data point as a separate cluster and iteratively merges the closest pairs of clusters until only one cluster remains or a stopping criterion is met.", "code":false},
                {"line": "Clustering has many applications across various domains, including customer segmentation, anomaly detection, image segmentation, and document clustering. It helps uncover hidden patterns in data and can provide valuable insights for decision-making and analysis.", "code":false}
            ],
            "postTags": "",
            "id": 0.03
        },
        {
            "postTitle": "Understanding Entity-Relationship (ER) Models and Their Attributes",
            "postLines": [
                {"line": "Entity-Relationship (ER) modeling is a fundamental technique used in database design to visually represent data and its relationships within a system. ER models use a graphical approach to depict entities (objects or concepts) and their relationships, making it easier to design and understand the structure of databases. The key components of an ER model are entities, relationships, and attributes. Among these, attributes play a crucial role in defining the properties and characteristics of entities and relationships."},
                {"line": "This article explores the different types of attributes in ER models, heighlighting their roles and significance."},
                {"line": "What Are Attributes in ER Models?", "code": false, "subtitle": true},
                {"line": "Attributes describe the properties or in other words characteristics of an entity or a relationship in an ER model. For example, in a database representing a library, an entity like \"Book\" may have attributes such as \"Title\", \"Author\", and \"ISBN\". Attributes provide detailed information about entities and relationships, enabling better data organization and retrieval.", "code": false, "subtitle": true},
                {"line": "Attributes can be categorized into various types based on their nature and usage. Below you will find the primary types of attributes used in ER modeling:", "code": false, "subtitle": false},
                {"line": "1. Simple Attributes", "code":false, "subtitle": true},
                {"line": "Simple attributes are atomic, indivisible properties. They hold single values and cannot be broken down further. For example:", "code": false, "subtitle": false},
                {"line": "\t ⸰ \"First Name\" and \"Last Name\" of a \"Student\" entity.", "code": false, "subtitle": false},
                {"line": "\t ⸰ \"Price\" of a \"Product\" entity.", "code": false, "subtitle": false},
                {"line": "Simple attributes are straightforward and are the most commonly used type of attributes.", "code": false, "subtitle": false},
                {"line": "2. Composite Attributes", "code": false, "subtitle": true},
                {"line": "Composite attributes are more complex than simple attributes by one level. These consist of multiple components that can be divided into smaller sub-parts, each of which holds meaningful information. As example we can list:", "code": false, "subtitle": false},
                {"line": "\t ⸰ \"Full Name\" can be divided into \"First Name\" and \"Last Name\"."},
                {"line": "\t ⸰ \"Address\" can be further subdivided into \"Street\", \"City\", \"State\", and \"Postal Code\".", "code": false, "subtitle": false},
                {"line": "Composite attributes provide flexibility in data representation, allowing users to store both detailed and summarized data.", "code": false, "subtitle": false},
                {"line": "3. Single-Valued Attributes", "code": false, "subtitle": true},
                {"line": "Single-valued attributes hold only one value for a given entity instance. For example:", "code": false, "subtitle": false},
                {"line": "\t ⸰ \"Age\" of a \"Person\" entity.", "code": false, "subtitle": false},
                {"line": "\t ⸰ \"Registration Number\" of a \"Vehicle\" entity.", "code": false, "subtitle": false},
                {"line": "These attributes are ideal for properties that naturally have only one value at a time.", "code": false, "subtitle": false},
                {"line": "4. Multi-Valued Attributes", "code": false, "subtitle": true},
                {"line": "These can hold multiple values for a single entity instance of a database. They may be for example:", "code": false, "subtitle": false},
                {"line": "\t ⸰ \"Phone Numbers\" of an \"Employee\" entity.", "code": false, "subtitle": false},
                {"line": "\t ⸰ \"Email Addresses\" of a \"Customer\" entity.", "code": false, "subtitle": false},
                {"line": "In ER models, multi-valued attributes are often represented using double ovals. They may need to be normalized during database design to create separate entities or tables for better organization.", "code": false, "subtitle": false},
                {"line": "5. Derived Attributes", "code": false, "subtitle": true},
                {"line": "Derived attributes are not stored directly in the database but are calculated based on other stored attributes. As examples we can name:", "code": false, "subtitle": false},
                {"line": "\t ⸰ \"Age\" can be derived from the \"Date of Birth\".", "code": false, "subtitle": false},
                {"line": "\t ⸰ \"Total Price\" can be calculated using \"Quantity\" and \"Unit Price\".", "code": false, "subtitle": false},
                {"line": "Derived attributes reduce redundancy and ensure consistency by relying on existing data for computation.", "code": false, "subtitle": false},
                {"line": "6. Key Attributes", "code": false, "subtitle": true} ,
                {"line": "Key attributes are unique identifiers for entity instances. These attributes ensure that each instance can be distinctly identified within the database. For example:", "code": false, "subtitle": false},
                {"line": "\t ⸰ \"Student ID\" for a \"Student\" entity."},
                {"line": "\"ISBN\" for a \"Book\" entity.", "code": false, "subtitle": false},
                {"line": "Key attributes are essential for establishing relationships between entities and maintaining data integrity.", "code": false, "subtitle": false},
                {"line": "7. Optional (or Null) Attributes", "code": false, "subtitle": true},
                {"line": "Optional attributes are those that may or not hold a value for a specific entity instance. For example:", "code": false, "subtitle": false},
                {"line": "\t ⸰ \"Middle Name\" of a \"Person\" entity might be optional.", "code": false, "subtitle": false},
                {"line": "\t ⸰ \"Discount\" on a \"Product\" might be optional.", "code": false, "subtitle": false},
                {"line": "Optional attributes add flexibility to the database schema by accommodationg incomplete or optional data.", "code": false, "subtitle": false},
                {"line": "Conclusion", "code": false, "subtitle": true},
                {"line": "Attributes in ER models play a vital role in defining the characteristics of entities and relationships, enabling comprehensive database designs. By understanding the various types of attributes - such as simple, composite, single-valued, multi-valued, derived, key, and optional - database designers can create more efficient, flexible, and scalable systems. Choosing the right attributes and organizing them effectively ensures that the database meets the requirements of the system it represents.", "code": false, "subtitle": false}
            ],
            "postTags": "Data Science, Data Bases, ER models, attributes"
        },
        {
            "postTitle": "Hierarchical Algorithms - Agglomerative Clustering",
            "postLines": [
                {"line": "Agglomerative clustering is a bottom-up hierarchical clustering algorithm. It starts with each data point as a separate cluster and then iteratively merges the closest pairs of clusters until only one cluster remains or a stopping criterion is met.", "code": false},
                {"line": "A a step-by-step explanation of how agglomerative clustering works:", "code": false},
                {"line": "", "code": true},
                {"line": "1. Initialization. ", "code": true},
                {"line": "      Start with each data point as a singleton cluster. Each data point is considered a cluster of its own.", "code": true},
                {"line": "2. Compute pairwise distances.", "code": true},
                {"line": "      Calculate the distance or similarity between all pairs of clusters. The distance between clusters can be computed using various metrics, such as Euclidean distance, Manhattan distance, or cosine similarity.", "code": true},
                {"line": "3. Merge closest clusters.", "code": true},
                {"line": "      Identify the two clusters that are closest to each other based on the distance metric. Merge these two clusters into a single cluster.", "code": true},
                {"line": "4. Update distance matrix.", "code": true},
                {"line": "      Update the distance to matrix to reflect the distances between the newly formed cluster and all other clusters. Depending on the linkage criteria chosen (e.g., single linkage, complete linkage, avarage linkage), the distance between clusters may be computed differently.", "code": true},
                {"line": "5. Repeat.", "code": true},
                {"line": "      Repeat stept 2-4 until only one cluster remains or a stopping criterion is met. This stopping criterion can be based on the number of desired clusters, a specified distance threshold, or other criteria.", "code": true},
                {"line": "", "code": true},
                {"line": "", "code": false},
                {"line": "The process of merging clusters continues iteratively until the desired number of clusters is obtained or until clusters become too dissimilar to merge further.", "code": false},
                {"line": "One key aspect of agglomerative clustering is the choice of linkage criteria, which determines how the distance between clusters is computed. There are several common linkage criteria:", "code": false},
                {"line": "'Single linkage' - the distance between two clusters is defined as the minimum distance between any two points in the two clusters. It tends to produce elongated clusters.", "code": false},
                {"line": "'Complete linkage' - the distance between two clusters is defined as the maximum distance between any two points in the two clusters. It tends to produce compact, spherical clusters.", "code": false},
                {"line": "'Average linkage' - the distance between two clusters is defined as the average distance between all pairs of points in the two clusters. It provides a balance between single and complete linkage.", "code": false},
                {"line": "Agglomerative clustering is intuitive and easy to understand, making it a popular choice for hierarchical clustering tasks. It can produce dendrogram visualizations that illustrate the hierarchical relationships between clusters, which can be helpful for understanding the structure of the data.", "code": false},
                {"line": "Agglomerative clustering can be used in various real-world applications across different domains. Some of the use cases include:", "code": false},
                {"line": "Market Segmentation", "code": false},
                {"line": "In marketing, agglomerative clustering can be used to segment customers based on their purchasing behavior or demographic information. By identifying groups of customers with similar characteristics, businesses can tailor their makreting strategies to target each segment more effecrively.", "code": false},
                {"line": "Genomic Analysis", "code": false},
                {"line": "In bioinformatics, agglomerative clustering can be applied to analyze gene expression data or DNA sequences. By clustering genes or genomic regions with similar expression patterns or sequences, researchers can uncover insights into genetic regulation, disease mechanisms, or evolutionary relationships.", "code": false},
                {"line": "Image Segmentation", "code": false},
                {"line": "In computer vision, agglomerative clustering can be used for image segmentation tasks. By clustering pixels based on their color or intensity values, images can be partitioned into distinct regions or objects. This is useful for tasks such as object detection, image segmentation, or content-based image retrieval.", "code": false},
                {"line": "Anomaly Detection", "code": false},
                {"line": "Agglomerative clustering can also be used for anomaly detection in various domains, such as network security, fraud detection, or equipment maintenance. By clustering data points and identifying clusters with significantly different characteristics from the rest, anomalies or outliers can be detected.", "code": false},
                {"line": "Document Clustering", "code": false},
                {"line": "In natural language processing (NLP), agglomerative clustering can be used for document clustering or topic modeling. By clustering documents based on their similarity in terms of word usage or semantic content, documents can be organized into thematic groups or topics, enabling tasks such as document classification, summarization, or recommendation.", "code": false},
                {"line": "These are just a few examples of how agglomerative clustering can be applied in practice. Its flexibility and versatility make it a valuable tool for exploratory data analysis, pattern recognition, and knowledge discovery in various fields.", "code": false}



                
                
            ],
            "postTags": "",
            "id": 1.0
        },
        {
            "postTitle": "Pros and Cons of Tools & Libraries dedicated for Data Science",
            "postLines": [
                {"line": "Python is a #highLevel programming language widely used across a variety of industries. Looking at the ranking charts of languages most commonly used among data scientists, it holds a very strong first place, well above the others by over 10%. We are noting a decline here, though, by 2%. Whilst the second in line, Java, is having a better time with 0.8% incline of usage in the data science industry. Also 10% further away places itself JavaScript programming language perhaps due to the campatibility with online websites and platforms. Other programming languages that follow our adorable and very visual JavaScript are not so far behind. Only by a little over 1% is C#, by 1.5% C/C++, and the last one being PHP with only a bit under 3% lacking to stand on the podium.", "code": false},
                {"line": "", "code": false},
                {"line": "", "code": false},
                {"line": "Data processing and modeling.", "code": false},
                {"line": "There are at least 8 Py libraries fit to accomplish such tasks." , "code":false},
                {"line": "1. NumPy (for Numerical Python) is a perfect tool for scientific computing and performing basic and advanced operations with arrays." , "code":false},
                {"line": "The library offers many handy features for performing operations on n-arrays and matrices in Python. It makes it possible to deal with arrays that store values of the same data type and facilitates the execution of mathematical operations on the arrays (and their vectorization). In fact, vectorizing mathematical operations on the NumPy array type increases performance and speeds up execution time." , "code":false},
                {"line": "2. SciPy (for Scientifical Python). This useful library includes modules for linear algebra, integration, optimization, and statistics. Its core functionality was built on NumPy, so its arrays use that library. SciPy works great for all sorts of scientific programming projects (science, math, and engineering). It offers efficient numerical routines such as numerical optimization, integration and others in sub-modules. The extensive documentation makes working with this library really easy." , "code":false},
                {"line": "3. Pandas is a library created to help developers work intuitively with 'tagged' and 'relational' data. It is based on two main data structures: 'Serial' (one-dimensional, like a Python list) and 'Dataframe' (two-dimensional, like a multi-column array). Pandas allows converting data structures into DataFrame objects, handling missing data and adding/removing columns from DataFrame, imputing missing files and plotting data with histogram or boxplot. It is an indispensable tool for data manipulation and visualization." , "code":false},
                {"line": "4. Keras is an excellent library for building neural networks and modeling. It is very simple to use and offers developers a good degree of extensibility. The library takes advantage of other packages (Theano or TensorFlow) as terminals. Moreover, Microsoft has integrated CNTK (Microsoft Cognitive Toolkit) to serve as another backend. This is a great choice if you want to experiment quickly using compact systems - the minimalist approach to design is really great!" , "code":false},
                {"line": "5. Scikit-Learn. It is an industry standard for Python-based data science projects. Scikits is a group of SciPy packages that were created for specific functionality - for example, image processing. Scikit-learn uses SciPy mathematical operations to expose a concise interface to the most common machine learning algorithms." , "code":false},
                {"line": "Data scientists use it to handle standard machine learning and data mining tasks such as clustering, regression, and classification. Another advantage? It comes with great documentation and offers high performance." , "code":false},
                {"line": "6. PyTorch is a framework that is perfect for data scientists who want to easily perform Deep Learning tasks. The tool allows performing tensor calculations with GPU acceleration. It is also used for other tasks - for example, to create dynamic computational graphs and automatically calculate gradients. PyTorch is based on Torch, which is an open-source Deep Learning library, implemented in C, with a skin in Lua." , "code":false},
                {"line": "7. TensorFlow is a Python framework popular to use in Machine Learning and Deep Learning, which was developed at Google Brain. It is the best tool for tasks such as object identification, voice recognition and many more. It lets you work with artificial neural networks that need to handle multiple data sets. The library includes several layer helpers (tflearn, tfslim, skflow) which make it even more functional. TensorFlow is constantly updated with new versions, including fixing possible security vulnerabilities or improving the integration of TensorFlow and the GPU." , "code": false},
                {"line": "8. XGBoost - Use this library to implement Machine Learning algorithms in the Gradient Boosting framework. XGBoost is portable, flexible and efficient. It offers parallel tree boosting that helps teams solve many data science problems. Another benegit is that developers can run the same code on leading distributed environments such as Hadoop, SGE, and MPI. " , "code":false},
                {"line": "9. Theano" , "code":false},
                {"line": "Data Visualisation" , "code":false},
                {"line": "1. Matplotlib is a standard data science library that helps produce data visualizations such as two-dimensional charts and graphs (histograms, scatter plots, non-Cartesian coordinate plots). Matplotlib is one of those plot libraries that are really useful in data science projects - it provides an object-oriented API for integrating plots into applications." , "code":false},
                {"line": " It is thanks to this library that Python can compete with scientific tools like MatLab or Mathematica. However, developers have to write more code than usual when using this library to build advanced visualizations. It is worth noting that popular plotting libraries work seamlessly with Matplotlib." , "code":false},
                {"line": "2. Seaborn is based on the previously mentioned" , "code":false},
                {"line": "" , "code":false},
                {"line": "" , "code":false},
                {"line": "" , "code":false},
                {"line": "" , "code":false},
                {"line": "" , "code":false},
                {"line": "" , "code":false},
                {"line": "" , "code":false},
                {"line": "" , "code":false},
                {"line": "" , "code":false},
                {"line": "" , "code":false},
                {"line": "" , "code":false},
                {"line": "" , "code":false},
                {"line": "" , "code":false}
            ],
            "postTags": "",
            "id": 2.10
        },
        {
            "postTitle": "NumPy - Efficient and Fast Open Source Python Library for Performing Numerical Operations",
            "postLines": [
                {"line": "#import NumPy library", "code": true},
                {"line": "import numpy as np", "code": true},
                {"line": "", "code": true},
                {"line": "#create Numpy array", "code": true},
                {"line": "regular_array = np.array([1, 2, 3, 4])", "code": true},
                {"line": "#print the created array", "code": true},
                {"line": "print(regular_array)", "code": true},
                {"line": "#array of zeros (shape of it within parentheses)", "code": true},
                {"line": "zeros_array = np.zeros((3, 3))", "code": true},
                {"line": "print(zeros_array)", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[[0. 0. 0.]", "code": true},
                {"line": " [0. 0. 0.]", "code": true},
                {"line": " [0. 0. 0.]]", "code": true},
                {"line": "#array of ones", "code": true},
                {"line": "ones_array = np.ones((3, 3))", "code": true},
                {"line": "print(ones_array)", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[[1. 1. 1.]", "code": true},
                {"line": " [1. 1. 1.]", "code": true},
                {"line": " [1. 1. 1.]]", "code": true},
                {"line": "#empty array", "code": true},
                {"line": "empty_array = np.empty((2, 3))", "code": true},
                {"line": "print(empty_array)", "code": true},
                {"line": "[[0. 0. 0.]", "code": true},
                {"line": " [0. 0. 0.]", "code": true},
                {"line": " [0. 0. 0.]]", "code": true},
                {"line": "#arange method on array", "code": true},
                {"line": "array_arange = np.arange(12)", "code": true},
                {"line": "print(array_arange)", "code": true},
                {"line": "[0 1 2 3 4 5 6 7 8 9 10 11]", "code": true},
                {"line": "array_arrange.reshape(3, 4)", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[[0, 1, 2, 3],", "code": true},
                {"line": " [4, 5, 6, 7],", "code": true},
                {"line": " [8, 9, 10, 11]]", "code": true},
                {"line": "#linspace - equaly spaced data elements", "code": true},
                {"line": "linear_data = np.linspace(11, 20, 5)", "code": true},
                {"line": "#11 - first element", "code": true},
                {"line": "#20 - last element", "code": true},
                {"line": "#5 - number of equidistant elements", "code": true},
                {"line": "print(linear_data)", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[11. 13.25 15.5 17.75 20. ]", "code": true},
                {"line": "#One dimensional array", "code": true},
                {"line": "one_dimension = np.arrange(15)", "code": true},
                {"line": "print(one_dimension)", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14]", "code": true},
                {"line": "#Two dimensional array", "code": true},
                {"line": "two_dimensions = one_dimension.reshape(3, 5)", "code": true},
                {"line": "print(two_dimensions)", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[[0, 1, 2, 3, 4],", "code": true},
                {"line": " [5, 6, 7, 8, 9]", "code": true},
                {"line": " [10, 11, 12, 13, 14]", "code": true},
                {"line": "#Three dimensional array", "code": true},
                {"line": "three_dimensions = np.arrange(27).reshape(3, 3, 3)", "code": true},
                {"line": "print(three_dimensions)", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[[[ 0 1 2 ]", "code": true},
                {"line": "  [ 3 4 5 ]", "code": true},
                {"line": "  [ 6 7 8 ]]", "code": true},
                {"line": " [[ 9 10 11 ]", "code": true},
                {"line": "  [ 12 13 14 ]", "code": true},
                {"line": "  [ 15 16 17 ]]", "code": true},
                {"line": " [[ 18 19 20 ]", "code": true},
                {"line": "  [ 21 22 23 ]", "code": true},
                {"line": "  [ 24 25 26 ]]]", "code": true}
            ],
            "postTags": "",
            "id": 2.11
        },
        {
            "postTitle": "PyGym Exercise 2.1",
            "postLines": [
                {"line": "Write a program that asks the user for their name and year of birth, then calculates and prints their age.", "code": false},
                {"line": "Examplary execution:", "code": false},
                {"line": "Give your name:", "code": false},
                {"line": "Johnny", "code": false},
                {"line": "Enter year of birth:", "code": false},
                {"line": "1989", "code": false},
                {"line": "John, you are 30 years old.", "code": false}
            ],
            "postTags": "",
            "id": 2.1
        },
        {
            "postTitle": "PyGym Exercise 2.2",
            "postLines": [
                {"line": "Write a program that asks the user for their name and year of birth, then calculates and prints their age.", "code": false},
                {"line": "Examplary execution:", "code": false},
                {"line": "Give your name:", "code": false},
                {"line": "Johnny", "code": false},
                {"line": "Enter year of birth:", "code": false},
                {"line": "1989", "code": false},
                {"line": "John, you are 30 years old.", "code": false}
            ],
            "postTags": "",
            "id": 2.2
        }
    ],
    "mathematics" : [
        {
            "postTitle": "Proof of the Arithmetic Mean and Geometric Mean (AM-GM) Inequality",
            "postLines": [
                {"line": "", "code": false, "image": true, "src" : ["/pdfs/AM_GM/AM_GM__Inequality-0.jpg", "/pdfs/AM_GM/AM_GM__Inequality-1.jpg"]}
            ]
        }
    ],
    "physics" : [
        {
            "postTitle": "Rigid Body and Rotation - Two Rotating Discs",
            "postLines": [
                {"line": "Two thin discs are attached to a horizontal axis, making 300 revolutions per second, 20 cm apart. To determine the speed of the bullet, it was fired in such a way that it pierced both targets at the same distance from the axis of rotation. Find the avarage speed of the bullet between the targets if the penetration points of the targets are offset by 18°.", "code": false},
                {"line": "Despite the complicated description, when we think carefully and imagine the whole situation, the task is very simple. We have the distance traveled, we do not have time and we have to calculate the avarage speed, by definition:", "code": false},
                {"line": "S = v*t", "code": false, "math": true},
                {"line": "So we need the time. It can be derived from the movement of the disks:", "code": false},
                {"line": "omega = 2 * pi * f", "code": false, "math": true},
                {"line": "alfa = omega * t", "code": false, "math": true},
                {"line": "Having these two simple equations, we can very easily derive the time:", "code": false},
                {"line": "t = (alfa)/(2 * pi * f)", "code": false, "math": true},
                {"line": "#array of zeros (shape of it within parentheses)", "code": true},
                {"line": "zeros_array = np.zeros((3, 3))", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[[0. 0. 0.]", "code": true},
                {"line": " [0. 0. 0.]", "code": true},
                {"line": " [0. 0. 0.]]", "code": true},
                {"line": "#array of ones", "code": true},
                {"line": "ones_array = np.ones((3, 3))", "code": true},
                {"line": "print(ones_array)", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[[1. 1. 1.]", "code": true},
                {"line": " [1. 1. 1.]", "code": true},
                {"line": " [1. 1. 1.]]", "code": true},
                {"line": "#empty array", "code": true},
                {"line": "empty_array = np.empty((2, 3))", "code": true},
                {"line": "print(empty_array)", "code": true},
                {"line": "[[0. 0. 0.]", "code": true},
                {"line": " [0. 0. 0.]", "code": true},
                {"line": " [0. 0. 0.]]", "code": true},
                {"line": "#arange method on array", "code": true},
                {"line": "array_arange = np.arange(12)", "code": true},
                {"line": "print(array_arange)", "code": true},
                {"line": "[0 1 2 3 4 5 6 7 8 9 10 11]", "code": true},
                {"line": "array_arrange.reshape(3, 4)", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[[0, 1, 2, 3],", "code": true},
                {"line": " [4, 5, 6, 7],", "code": true},
                {"line": " [8, 9, 10, 11]]", "code": true},
                {"line": "#linspace - equaly spaced data elements", "code": true},
                {"line": "linear_data = np.linspace(11, 20, 5)", "code": true},
                {"line": "#11 - first element", "code": true},
                {"line": "#20 - last element", "code": true},
                {"line": "#5 - number of equidistant elements", "code": true},
                {"line": "print(linear_data)", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[11. 13.25 15.5 17.75 20. ]", "code": true},
                {"line": "#One dimensional array", "code": true},
                {"line": "one_dimension = np.arrange(15)", "code": true},
                {"line": "print(one_dimension)", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14]", "code": true},
                {"line": "#Two dimensional array", "code": true},
                {"line": "two_dimensions = one_dimension.reshape(3, 5)", "code": true},
                {"line": "print(two_dimensions)", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[[0, 1, 2, 3, 4],", "code": true},
                {"line": " [5, 6, 7, 8, 9]", "code": true},
                {"line": " [10, 11, 12, 13, 14]", "code": true},
                {"line": "#Three dimensional array", "code": true},
                {"line": "three_dimensions = np.arrange(27).reshape(3, 3, 3)", "code": true},
                {"line": "print(three_dimensions)", "code": true},
                {"line": "#Output:", "code": true},
                {"line": "[[[ 0 1 2 ]", "code": true},
                {"line": "  [ 3 4 5 ]", "code": true},
                {"line": "  [ 6 7 8 ]]", "code": true},
                {"line": " [[ 9 10 11 ]", "code": true},
                {"line": "  [ 12 13 14 ]", "code": true},
                {"line": "  [ 15 16 17 ]]", "code": true},
                {"line": " [[ 18 19 20 ]", "code": true},
                {"line": "  [ 21 22 23 ]", "code": true},
                {"line": "  [ 24 25 26 ]]]", "code": true}
            ],
            "postTags": "",
            "id": 2.0
        },
        {
            "postTitle": "PyGym Exercise 2.1",
            "postLines": [
                {"line": "Write a program that asks the user for their name and year of birth, then calculates and prints their age.", "code": false},
                {"line": "Examplary execution:", "code": false},
                {"line": "Give your name:", "code": false},
                {"line": "Johnny", "code": false},
                {"line": "Enter year of birth:", "code": false},
                {"line": "1989", "code": false},
                {"line": "John, you are 30 years old.", "code": false}
            ],
            "postTags": "",
            "id": 2.1
        },
        {
            "postTitle": "PyGym Exercise 2.2",
            "postLines": [
                {"line": "Write a program that asks the user for their name and year of birth, then calculates and prints their age.", "code": false},
                {"line": "Examplary execution:", "code": false},
                {"line": "Give your name:", "code": false},
                {"line": "Johnny", "code": false},
                {"line": "Enter year of birth:", "code": false},
                {"line": "1989", "code": false},
                {"line": "John, you are 30 years old.", "code": false}
            ],
            "postTags": "",
            "id": 2.2
        }
    ],
    "physics_particle" : [
        {
            "postTitle": "PyGym Exercise 2.2",
            "postLines": [
                {"line": "Write a program that asks the user for their name and year of birth, then calculates and prints their age.", "code": false},
                {"line": "Examplary execution:", "code": false},
                {"line": "Give your name:", "code": false},
                {"line": "Johnny", "code": false},
                {"line": "Enter year of birth:", "code": false},
                {"line": "1989", "code": false},
                {"line": "John, you are 30 years old.", "code": false}
            ],
            "postTags": "",
            "id": 0.0
        },
        {
            "postTitle": "PyGym Exercise 2.2",
            "postLines": [
                {"line": "Write a program that asks the user for their name and year of birth, then calculates and prints their age.", "code": false},
                {"line": "Examplary execution:", "code": false},
                {"line": "Give your name:", "code": false},
                {"line": "Johnny", "code": false},
                {"line": "Enter year of birth:", "code": false},
                {"line": "1989", "code": false},
                {"line": "John, you are 30 years old.", "code": false}
            ],
            "postTags": "",
            "id": 0.1
        },{
            "postTitle": "PyGym Exercise 2.2",
            "postLines": [
                {"line": "Write a program that asks the user for their name and year of birth, then calculates and prints their age.", "code": false},
                {"line": "Examplary execution:", "code": false},
                {"line": "Give your name:", "code": false},
                {"line": "Johnny", "code": false},
                {"line": "Enter year of birth:", "code": false},
                {"line": "1989", "code": false},
                {"line": "John, you are 30 years old.", "code": false}
            ],
            "postTags": "",
            "id": 0.2
        },{
            "postTitle": "PyGym Exercise 2.2",
            "postLines": [
                {"line": "Write a program that asks the user for their name and year of birth, then calculates and prints their age.", "code": false},
                {"line": "Examplary execution:", "code": false},
                {"line": "Give your name:", "code": false},
                {"line": "Johnny", "code": false},
                {"line": "Enter year of birth:", "code": false},
                {"line": "1989", "code": false},
                {"line": "John, you are 30 years old.", "code": false}
            ],
            "postTags": "",
            "id": 0.3
        },
        {
            "postTitle": "PyGym Exercise 2.2",
            "postLines": [
                {"line": "Write a program that asks the user for their name and year of birth, then calculates and prints their age.", "code": false},
                {"line": "Examplary execution:", "code": false},
                {"line": "Give your name:", "code": false},
                {"line": "Johnny", "code": false},
                {"line": "Enter year of birth:", "code": false},
                {"line": "1989", "code": false},
                {"line": "John, you are 30 years old.", "code": false}
            ],
            "postTags": "",
            "id": 0.4
        }
    ],
    "pentesting" : [
        {
            "postTitle": "Types of Vulnerabilities",
            "postLines": [
                {"line": "Misconfigurations", "code": false},
                {"line": "Kernel Flaws", "code": false},
                {"line": "Insufficient Input Validations", "code": false},
                {"line": "Symbolic Links (Symlinks)", "code": false},
                {"line": "File Descriptor Attacks", "code": false},
                {"line": "Tace Conditions", "code": false},
                {"line": "Buffer Overflows", "code": false},
                {"line": "Incorrect File & Directory Permissions", "code": false}
            ],
            "postTags": "",
            "id": 1.01
        }
    ]   
  } 
]